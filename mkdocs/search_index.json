{
    "docs": [
        {
            "location": "/", 
            "text": "Go-Smart Simulation Architecture (GSSA)\n\n\nPrimary authors\n : \nNUMA Engineering Services Ltd\n (NUMA), Dundalk, Ireland\n\n\nProject website\n : \nhttp://www.gosmart-project.eu/\n\n\nThis project is co-funded by the European Commission under grant agreement no. 600641.\n\n\nThis tool, GSSA, provides scripts for running a generic simulation server, with support for Docker-based webuser-configurable simulation tools, and the configuration for the \nCrossbar.io\n WAMP router.\n\n\nDependencies\n\n\n\n\nPython 2.7\n\n\nPython 3\n\n\nElmer (with NUMA modifications)\n\n\nGMSH\n\n\nVTK 5.8\n\n\nlibjsoncpp-dev\n\n\n(Python 3) munkres pyyaml\n\n\n(Python 2) PythonOCC\n\n\n\n\nInstallation\n\n\nCMake installation is recommended from an out-of-source build directory.\n\n\nUsage\n\n\nThe simulation workflow may be launched by the command\n\n\n  go-smart-launcher settings.xml\n\n\n\n\nwhere \nsettings.xml\n is a GSSF-XML file. Adding --help will show documentation of command line arguments.", 
            "title": "Home"
        }, 
        {
            "location": "/#go-smart-simulation-architecture-gssa", 
            "text": "Primary authors  :  NUMA Engineering Services Ltd  (NUMA), Dundalk, Ireland  Project website  :  http://www.gosmart-project.eu/  This project is co-funded by the European Commission under grant agreement no. 600641.  This tool, GSSA, provides scripts for running a generic simulation server, with support for Docker-based webuser-configurable simulation tools, and the configuration for the  Crossbar.io  WAMP router.", 
            "title": "Go-Smart Simulation Architecture (GSSA)"
        }, 
        {
            "location": "/#dependencies", 
            "text": "Python 2.7  Python 3  Elmer (with NUMA modifications)  GMSH  VTK 5.8  libjsoncpp-dev  (Python 3) munkres pyyaml  (Python 2) PythonOCC", 
            "title": "Dependencies"
        }, 
        {
            "location": "/#installation", 
            "text": "CMake installation is recommended from an out-of-source build directory.", 
            "title": "Installation"
        }, 
        {
            "location": "/#usage", 
            "text": "The simulation workflow may be launched by the command    go-smart-launcher settings.xml  where  settings.xml  is a GSSF-XML file. Adding --help will show documentation of command line arguments.", 
            "title": "Usage"
        }, 
        {
            "location": "/comparison/", 
            "text": "Comparison of GSSA-XML documents\n\n\nThis tool allows diff-ing of two XML documents based on their conceptual content\nand returning a human-readable comparison.\n\n\ngo-smart-comparator\n\n\nThis is a simple wrapper script taking two GSSA-XML files and outputting the\ndifference in human-readable format.\n\n\nUsage\n\n\nThe script takes only two arguments: the files to be compared.\n\n\ngo-smart-comparator file1.xml file2.xml\n\n\n\nMethodology\n\n\nThe \ngssa.comparator\n module loads each file into a\n\nSimulationDefinition\n object, which has a \nCDM\n-based understanding\nof its content. Moreover, it is capable of diffing itself against another\n\nSimulationDefinition\n. The \nSimulationDefinition\n of the first file passed\nto the \nComparator\n object (the first file argument to\n\ngo-smart-comparator\n) is given the \nSimulationDefinition\n of the second. It\nreturns the description of the difference referring to itself as \nleft\n or\n\nthis\n and the other as \nright\n or \nthat\n.\n\n\nNote that the comparator is unable to account for non-embedded detail, such as\ngeometry files of the same name, differences of solver version and numerical\nmodels with a separately passed definition.", 
            "title": "Comparison"
        }, 
        {
            "location": "/comparison/#comparison-of-gssa-xml-documents", 
            "text": "This tool allows diff-ing of two XML documents based on their conceptual content\nand returning a human-readable comparison.", 
            "title": "Comparison of GSSA-XML documents"
        }, 
        {
            "location": "/comparison/#go-smart-comparator", 
            "text": "This is a simple wrapper script taking two GSSA-XML files and outputting the\ndifference in human-readable format.  Usage  The script takes only two arguments: the files to be compared.  go-smart-comparator file1.xml file2.xml", 
            "title": "go-smart-comparator"
        }, 
        {
            "location": "/comparison/#methodology", 
            "text": "The  gssa.comparator  module loads each file into a SimulationDefinition  object, which has a  CDM -based understanding\nof its content. Moreover, it is capable of diffing itself against another SimulationDefinition . The  SimulationDefinition  of the first file passed\nto the  Comparator  object (the first file argument to go-smart-comparator ) is given the  SimulationDefinition  of the second. It\nreturns the description of the difference referring to itself as  left  or this  and the other as  right  or  that .  Note that the comparator is unable to account for non-embedded detail, such as\ngeometry files of the same name, differences of solver version and numerical\nmodels with a separately passed definition.", 
            "title": "Methodology"
        }, 
        {
            "location": "/errors/", 
            "text": "Error types\n\n\nVery basic unified error types are provided, to help distinguish between user\nerrors, programmer errors, modeller errors and errors of unknown responsibility.\n\n\nThese contain codes which can be matched by the client-side tools. In theory,\nall errors returned from GSSA (and many from GSSF) will be one of these. Any\nerrors thrown beneath will be caught and wrapped accordingly.\n\n\nThese are passed back across WAMP to the client, which is why we do not wish to\npass arbitrary exceptions from Python server-side routines.\n\n\n\n\n\n\n\n\nError Code\n\n\nError ID\n\n\nIntepretation\n\n\nGSSF exception class (if app.)\n\n\n\n\n\n\n\n\n\n\nSUCCESS\n\n\n0\n\n\nAll worked\n\n\n-\n\n\n\n\n\n\nE_UNKNOWN\n\n\n1\n\n\nError of unknown origin\n\n\nGoSmartError\n\n\n\n\n\n\nE_CLIENT\n\n\n2\n\n\nTriggered by an issue on the client side, such as illogical input\n\n\nGoSmartClientError\n\n\n\n\n\n\nE_SERVER\n\n\n3\n\n\nProblems with the server or server-side tools\n\n\nGoSmartServerError\n\n\n\n\n\n\nE_MODEL\n\n\n4\n\n\nModelling problem, where the server cannot complete the task for physical/mathematical/numerical/syntactical reasons that are the responsibility of the model developer\n\n\nGoSmartModelError\n\n\n\n\n\n\n\n\nIn general, we err on the side of caution and attribute anything uncertain to\n\nE_SERVER\n or \nE_UNKNOWN\n. However, it may be, in the future, that being less\nconservative with \nE_MODEL\n will help provide automatic feedback on issues.", 
            "title": "Errors"
        }, 
        {
            "location": "/errors/#error-types", 
            "text": "Very basic unified error types are provided, to help distinguish between user\nerrors, programmer errors, modeller errors and errors of unknown responsibility.  These contain codes which can be matched by the client-side tools. In theory,\nall errors returned from GSSA (and many from GSSF) will be one of these. Any\nerrors thrown beneath will be caught and wrapped accordingly.  These are passed back across WAMP to the client, which is why we do not wish to\npass arbitrary exceptions from Python server-side routines.     Error Code  Error ID  Intepretation  GSSF exception class (if app.)      SUCCESS  0  All worked  -    E_UNKNOWN  1  Error of unknown origin  GoSmartError    E_CLIENT  2  Triggered by an issue on the client side, such as illogical input  GoSmartClientError    E_SERVER  3  Problems with the server or server-side tools  GoSmartServerError    E_MODEL  4  Modelling problem, where the server cannot complete the task for physical/mathematical/numerical/syntactical reasons that are the responsibility of the model developer  GoSmartModelError     In general, we err on the side of caution and attribute anything uncertain to E_SERVER  or  E_UNKNOWN . However, it may be, in the future, that being less\nconservative with  E_MODEL  will help provide automatic feedback on issues.", 
            "title": "Error types"
        }, 
        {
            "location": "/gssa-xml/", 
            "text": "Go-Smart Simulation Architecture XML Format (GSSA-XML)\n\n\nNote\n: this is distinct from \nGSSF-XML\n.\n\n\nGSSA-XML is documented as an XML Schema in the \nschema\n directory of the source\ntree. However, to provide a human-readable resource, it is described also here:\n\n\nsimulationDefinition\n\n    \ntransferrer class=\n(http|tmp)\n\n        \n!-- See Transferrers documentation --\n\n    \n/transferrer\n\n    \nalgorithms\n\n        \n!-- See Algorithms documentation --\n\n    \n/algorithms\n\n    \nparameters\n\n        \n!-- See Parameters#concrete-parameters documentation --\n\n    \n/parameters\n\n    \nnumericalModel\n\n        \nneedles\n\n            \nneedle index=\nNIX\n class=\nNCL\n file=\nNFILE\n\n                \nparameters\n\n                    \n!-- See Parameters#concrete-parameters documentation --\n\n                \n/parameters\n\n            \n/needle\n\n            ...\n        \n/needles\n\n        \nregions\n\n            \nregion id=\nRID\n name=\nRNAME\n format=\nRFORMAT:(zone|surface|both)\n input=\nRINPUT\n groups=\nRGROUPS\n /\n\n            ...\n        \n/regions\n\n        \ndefinition name=\nDFAMILY\n [ file=\nDFILE\n ]\n\n            \n!-- Family-specific content (see documentation for each family) --\n\n        \n/definition\n\n    \n/numericalModel\n\n\n/simulationDefinition\n\n\n\n\n\nThe needle index, \nNIX\n, indicates the name by which this needle should be\nreferred to. They should be integers, ordering the needles contiguously. The\nclass, \nNCL\n, identifies how a needle should be incorporated into the simulation\nand should either be \nsolid-boundary\n or \nboundary\n. The exact needle definition\nis supplied by \nNFILE\n, which should be of the form \nlibrary:LIBRARYTYPE\n or\n\nfile:INPUTFILENAME.stl\n. Within each needle node is another list of\nneedle-specific parameters.\n\n\nEach region should have an \nRID\n that uniquely refers to them within the\nsimulation. The \nRNAME\n is a context-providing name that may be used, such as\n\norgan\n or \ntumour\n. A simple way to generate IDs is to add an ordinal index to\nthe name, e.g., \ntumour-1\n. The \nRFORMAT\n indicates how the region should be\ntreated, as a zone, surface or both (volumetric subdomain, boundary, or embedded\nboundary). The \nRINPUT\n is the filename of the STL or VTP input file defining the\nsurface. The collection of region groups of which this region is a member should\nbe specified in the \nRGROUPS\n field, joined by \"\n;\n\".\n\n\nThe definition \nDFAMILY\n selects the family that should handle the definition.\nNote that it may be provided as a TAR.GZ (allowing, for instance, Python\nmodules) using the \nDFILE\n attribute, but is otherwise the body of the\n\ndefinition\n tag itself.", 
            "title": "GSSA XML Format"
        }, 
        {
            "location": "/gssa-xml/#go-smart-simulation-architecture-xml-format-gssa-xml", 
            "text": "Note : this is distinct from  GSSF-XML .  GSSA-XML is documented as an XML Schema in the  schema  directory of the source\ntree. However, to provide a human-readable resource, it is described also here:  simulationDefinition \n     transferrer class= (http|tmp) \n         !-- See Transferrers documentation -- \n     /transferrer \n     algorithms \n         !-- See Algorithms documentation -- \n     /algorithms \n     parameters \n         !-- See Parameters#concrete-parameters documentation -- \n     /parameters \n     numericalModel \n         needles \n             needle index= NIX  class= NCL  file= NFILE \n                 parameters \n                     !-- See Parameters#concrete-parameters documentation -- \n                 /parameters \n             /needle \n            ...\n         /needles \n         regions \n             region id= RID  name= RNAME  format= RFORMAT:(zone|surface|both)  input= RINPUT  groups= RGROUPS  / \n            ...\n         /regions \n         definition name= DFAMILY  [ file= DFILE  ] \n             !-- Family-specific content (see documentation for each family) -- \n         /definition \n     /numericalModel  /simulationDefinition   The needle index,  NIX , indicates the name by which this needle should be\nreferred to. They should be integers, ordering the needles contiguously. The\nclass,  NCL , identifies how a needle should be incorporated into the simulation\nand should either be  solid-boundary  or  boundary . The exact needle definition\nis supplied by  NFILE , which should be of the form  library:LIBRARYTYPE  or file:INPUTFILENAME.stl . Within each needle node is another list of\nneedle-specific parameters.  Each region should have an  RID  that uniquely refers to them within the\nsimulation. The  RNAME  is a context-providing name that may be used, such as organ  or  tumour . A simple way to generate IDs is to add an ordinal index to\nthe name, e.g.,  tumour-1 . The  RFORMAT  indicates how the region should be\ntreated, as a zone, surface or both (volumetric subdomain, boundary, or embedded\nboundary). The  RINPUT  is the filename of the STL or VTP input file defining the\nsurface. The collection of region groups of which this region is a member should\nbe specified in the  RGROUPS  field, joined by \" ; \".  The definition  DFAMILY  selects the family that should handle the definition.\nNote that it may be provided as a TAR.GZ (allowing, for instance, Python\nmodules) using the  DFILE  attribute, but is otherwise the body of the definition  tag itself.", 
            "title": "Go-Smart Simulation Architecture XML Format (GSSA-XML)"
        }, 
        {
            "location": "/families/", 
            "text": "Go-Smart Simulation Model Families\n\n\nFamilies represent groups of workflows that are simulated in approximately the\nsame way, or at least by using the same tools. This is slightly more specific\nthan a workflow as, for example, the Docker workflow has a separate family for\neach Docker image. It corresponds more accurately to a single configuration\nsystem. This comprises a pair: a subclass of \ngssa.family.Family\n\nthat contains instructions for interpreting \nGSSA-XML\n for this\ntype of simulation and writing any necessary tool-specific configuration files,\nand the simulation tools themselves.\n\n\nTwo examples are \nGSSF\n, which is also a fully fledged\nworkflow, and \nFEniCS\n, which depends on pre-meshing by\nthe \nGSSF CGAL mesher component\n.\n\n\nTo find families, the \ngssa.family\n module scans for files in the directory of\nthe \ngssa.families\n module. \nTODO\n: extend this to user-configurable locations.\n\n\nNote\n: family modules are run as part of the Python server - this means they\nare privileged and should only be included from highly \ntrusted\n sources, as\nwith other codes running as \nwww-data\n. They are not sandboxed or intended to be\nuser-supplied, but constitute a basic plug-in framework. The longer-term\nintention is to migrate to a proper plug-in framework, where community developed\nfamilies may be added in, running as an unprivileged user. Of course, this would\nstill require a higher level of trust than given to external user code, which\nonly runs sandboxed in Docker.", 
            "title": "Families"
        }, 
        {
            "location": "/families/#go-smart-simulation-model-families", 
            "text": "Families represent groups of workflows that are simulated in approximately the\nsame way, or at least by using the same tools. This is slightly more specific\nthan a workflow as, for example, the Docker workflow has a separate family for\neach Docker image. It corresponds more accurately to a single configuration\nsystem. This comprises a pair: a subclass of  gssa.family.Family \nthat contains instructions for interpreting  GSSA-XML  for this\ntype of simulation and writing any necessary tool-specific configuration files,\nand the simulation tools themselves.  Two examples are  GSSF , which is also a fully fledged\nworkflow, and  FEniCS , which depends on pre-meshing by\nthe  GSSF CGAL mesher component .  To find families, the  gssa.family  module scans for files in the directory of\nthe  gssa.families  module.  TODO : extend this to user-configurable locations.  Note : family modules are run as part of the Python server - this means they\nare privileged and should only be included from highly  trusted  sources, as\nwith other codes running as  www-data . They are not sandboxed or intended to be\nuser-supplied, but constitute a basic plug-in framework. The longer-term\nintention is to migrate to a proper plug-in framework, where community developed\nfamilies may be added in, running as an unprivileged user. Of course, this would\nstill require a higher level of trust than given to external user code, which\nonly runs sandboxed in Docker.", 
            "title": "Go-Smart Simulation Model Families"
        }, 
        {
            "location": "/cdm/overview/", 
            "text": "Go-Smart Clinical Domain Model\n\n\nThe Clinical\n\n\nAlgorithms", 
            "title": "Overview"
        }, 
        {
            "location": "/cdm/overview/#go-smart-clinical-domain-model", 
            "text": "The Clinical", 
            "title": "Go-Smart Clinical Domain Model"
        }, 
        {
            "location": "/cdm/overview/#algorithms", 
            "text": "", 
            "title": "Algorithms"
        }, 
        {
            "location": "/cdm/algorithms/", 
            "text": "Go-Smart Simulation Algorithms\n\n\nThese are members of the \nCDM\n that provide something akin to lambda\ncalculus to Go-Smart. They are database defined, have textual body in an\nunspecified language, return a parameter as a \nResult\n and take named arguments\nthat must be supplied by the numerical model as a condition of forming a valid\n\nCombination\n.\n\n\nDefinition\n\n\nThey can be defined in \nGSSA-XML\n, within the \nalgorithms /\n node\nas follows:\n\n\n    \nalgorithm result=\nRESULT\n\n        \narguments\n\n            \nargument name=\nARGNAME\n /\n\n        \n/arguments\n\n        \ncontent\n\n            ALGORITHMDEFINITION\n        \n/content\n\n    \n/algorithm\n\n\n\n\n\nThe \nALGORITHMDEFINITION\n may be defined in any language the simulation family\nwill understand (or, more accurately, the ultimate third-party simulation tool).\nExamples include MATC (for \nGSSF\n) and Python (for\n\nFEniCS\n). The \nRESULT\n is conventionally an upper-case,\nunderscore-spaced slug that can be used in place of a conventional \"constant\"\nparameter. Arguments are specified solely by name, not type (as we do not even\nknow the applicable language). They are expected to be supplied by the\nsimulation procedure at run-time.\n\n\nWhile this is no less secure than the numerical\nmodel running on the Docker instance from an administrator perspective, it should\nbe noted that the provenance of\nthe algorithm may well be different, and if the author of the numerical model (or\nDocker instance) is\nconcerned about data leakage from their instance, they should take adequate\nprecaution. Within the Python Docker module, the algorithm will not be called\nexcept as requested by the numerical module.", 
            "title": "Algorithms"
        }, 
        {
            "location": "/cdm/algorithms/#go-smart-simulation-algorithms", 
            "text": "These are members of the  CDM  that provide something akin to lambda\ncalculus to Go-Smart. They are database defined, have textual body in an\nunspecified language, return a parameter as a  Result  and take named arguments\nthat must be supplied by the numerical model as a condition of forming a valid Combination .", 
            "title": "Go-Smart Simulation Algorithms"
        }, 
        {
            "location": "/cdm/algorithms/#definition", 
            "text": "They can be defined in  GSSA-XML , within the  algorithms /  node\nas follows:       algorithm result= RESULT \n         arguments \n             argument name= ARGNAME  / \n         /arguments \n         content \n            ALGORITHMDEFINITION\n         /content \n     /algorithm   The  ALGORITHMDEFINITION  may be defined in any language the simulation family\nwill understand (or, more accurately, the ultimate third-party simulation tool).\nExamples include MATC (for  GSSF ) and Python (for FEniCS ). The  RESULT  is conventionally an upper-case,\nunderscore-spaced slug that can be used in place of a conventional \"constant\"\nparameter. Arguments are specified solely by name, not type (as we do not even\nknow the applicable language). They are expected to be supplied by the\nsimulation procedure at run-time.  While this is no less secure than the numerical\nmodel running on the Docker instance from an administrator perspective, it should\nbe noted that the provenance of\nthe algorithm may well be different, and if the author of the numerical model (or\nDocker instance) is\nconcerned about data leakage from their instance, they should take adequate\nprecaution. Within the Python Docker module, the algorithm will not be called\nexcept as requested by the numerical module.", 
            "title": "Definition"
        }, 
        {
            "location": "/cdm/contexts/", 
            "text": "Clinical Domain Model - Contexts\n\n\nContexts\n are, normally, physical media in which a procedure takes place. They\nare often referred to as \nOrgans\n, but strictly, this need not be the case -\nphantoms or \nex vivo\n samples are valid Contexts.", 
            "title": "Contexts"
        }, 
        {
            "location": "/cdm/contexts/#clinical-domain-model-contexts", 
            "text": "Contexts  are, normally, physical media in which a procedure takes place. They\nare often referred to as  Organs , but strictly, this need not be the case -\nphantoms or  ex vivo  samples are valid Contexts.", 
            "title": "Clinical Domain Model - Contexts"
        }, 
        {
            "location": "/cdm/parameters/", 
            "text": "Go-Smart Simulation Parameters\n\n\nParameters, within a \nCDM\n context, are entities uniquely\ndefined by their name, representing a value to be passed for simulation. This\ncould be a solver setting, a physical constant, a representation of clinician\nbehaviour over time, or essentially anything that can be encoded in a JSON\nobject. Interpretation, on the simulation side, is the responsibility of the\n\nfamily\n and/or the simulation tool. On the client side, it is the\nresponsibility of the UI engine to take the value and the widget definition and form a\nuseful interface.\n\n\nWhile a Parameter has a specific value, type and UI widget when concretized, that is,\nprepared for\na specific simulation, it may, in the abstract, have many \nParameter Attributions\n\neach attributing it to a different valid Combination, potentially with a different value,\ntype and UI widget each.\n\n\nParameter types\n\n\nThe Parameter type is specified in a string field. It should be lowercase,\nholding the name of a basic type (e.g. \nstring\n, \ninteger\n, \nboolean\n, \nfloat\n)\nor, if an array, it should be written \narray(BASICTYPE)\n where \nTYPE\n is\nthe type of elements of the array. If it is an array of tuples, it should be\nwritten \narray(BASICTYPE1, BASICTYPE2)\n, etc.\n\n\nParameter Attributions\n\n\nA \nParameter Attribution\n\nis an attachment record, linking a Parameter to another CDM entity, such as a\nNumerical Model or Needle. A Parameter Attribution has similar columns to a\nParameter, although not a name, instead referencing a ParameterId.\n\n\nParameter Attributions are matched to components in a limiting fashion. That is, a\nParameter Attribution can apply to a specific Numerical Model, or a specific\n(Numerical Model, Protocol) pair, or a specific (Numerical Model, Context, Needle)\ntriple, and so forth. A Parameter Attribution always applies to a Combination of\nentities \nunless\n at least one of the entities referenced in the Parameter\nAttribution is different\nto those named in the Combination. Consequently, a Parameter Attribution\nhaving no entity field filled in, will attribute a Parameter to all Combinations. (This may\nbe the case for universal constants, but is otherwise not especially useful).\n\n\nEach Parameter Attribution only be attributed to one specific component of\neach type. This does not prevent multiple otherwise identical Parameter\nAttributions from coexisting, each applying to a different Context, say.\n\n\nPlaceholders\n\n\nA Parameter Attribution with a null value is referred to as a Placeholder. When\nit applies to a given Combination, this\nindicates to the Combination-forming procedure that another Parameter\nAttribution applying to that Combination \nmust\n provide a non-null value for that\nParameter, or the whole Combination is invalid. This is used by a Numerical\nModel, for instance, to require a value for an essential Parameter; it could\nprovide a Placeholder entry for \nSETTING_FINAL_TIMESTEP\n, thereby ensuring any\nCombination incorporating it must have \nSETTING_FINAL_TIMESTEP\n provided by\nanother component, say, a Protocol.\n\n\nIt is possible for a Parameter Attribution to specify slightly more flexible\nbehaviour in this case - this is defined by a Parameter Attribution enum field.\nInstead of barring the formation of the Combination, it could prompt the\nsimulating user with an interactive widget when the Combination is used. Bear in\nmind, particularly in a medical setting, that this may be a clinician and not a\ntechnical user.\n\n\nConcrete Parameters\n\n\nWhen a Simulation is to be run, all of the Parameter Attributions applying to\nits Combination\nare grouped. A hierarchical algorithm picks one Parameter Attribution for each\nParameter that appears. Any Parameters that has a placeholder but no\nvalue-supplying Parameter Attributions must be given values by the end-user. For\nthis purpose, Parameter Attributions (so the placeholder) have a \nwidget\n field.\nThe exact choices in rendering this are the responsibility of the UI.\n\n\nThis \nattribution selection\n creates an entity, a variation of\nParameter tied to a Simulation with a unique set of field values provided by the\nwinning Parameter Attribution (or user) - this is refered to as a \nConcrete\nParameter\n and corresponds to the Parameter concept as seen by the \nsimulation\nserver\n.\n\n\nThe Concrete Parameters for a simulation appear in the \nGSSA-XML\n\nin the following format:\n\n\nparameters\n\n    \nparameter name=\nPARAMNAME\n value=\nPARAMATTRVALUE\n type=\nPARAMATTRTYPE\n /\n\n    ...\n\n/parameters\n\n\n\n\n\nThe \nPARAMATTRTYPE\n defines the type of \nPARRAMATTRVALUE\n and should be a type\nas described in the \nParameter types\n section.", 
            "title": "Parameters"
        }, 
        {
            "location": "/cdm/parameters/#go-smart-simulation-parameters", 
            "text": "Parameters, within a  CDM  context, are entities uniquely\ndefined by their name, representing a value to be passed for simulation. This\ncould be a solver setting, a physical constant, a representation of clinician\nbehaviour over time, or essentially anything that can be encoded in a JSON\nobject. Interpretation, on the simulation side, is the responsibility of the family  and/or the simulation tool. On the client side, it is the\nresponsibility of the UI engine to take the value and the widget definition and form a\nuseful interface.  While a Parameter has a specific value, type and UI widget when concretized, that is,\nprepared for\na specific simulation, it may, in the abstract, have many  Parameter Attributions \neach attributing it to a different valid Combination, potentially with a different value,\ntype and UI widget each.", 
            "title": "Go-Smart Simulation Parameters"
        }, 
        {
            "location": "/cdm/parameters/#parameter-types", 
            "text": "The Parameter type is specified in a string field. It should be lowercase,\nholding the name of a basic type (e.g.  string ,  integer ,  boolean ,  float )\nor, if an array, it should be written  array(BASICTYPE)  where  TYPE  is\nthe type of elements of the array. If it is an array of tuples, it should be\nwritten  array(BASICTYPE1, BASICTYPE2) , etc.", 
            "title": "Parameter types"
        }, 
        {
            "location": "/cdm/parameters/#parameter-attributions", 
            "text": "A  Parameter Attribution \nis an attachment record, linking a Parameter to another CDM entity, such as a\nNumerical Model or Needle. A Parameter Attribution has similar columns to a\nParameter, although not a name, instead referencing a ParameterId.  Parameter Attributions are matched to components in a limiting fashion. That is, a\nParameter Attribution can apply to a specific Numerical Model, or a specific\n(Numerical Model, Protocol) pair, or a specific (Numerical Model, Context, Needle)\ntriple, and so forth. A Parameter Attribution always applies to a Combination of\nentities  unless  at least one of the entities referenced in the Parameter\nAttribution is different\nto those named in the Combination. Consequently, a Parameter Attribution\nhaving no entity field filled in, will attribute a Parameter to all Combinations. (This may\nbe the case for universal constants, but is otherwise not especially useful).  Each Parameter Attribution only be attributed to one specific component of\neach type. This does not prevent multiple otherwise identical Parameter\nAttributions from coexisting, each applying to a different Context, say.  Placeholders  A Parameter Attribution with a null value is referred to as a Placeholder. When\nit applies to a given Combination, this\nindicates to the Combination-forming procedure that another Parameter\nAttribution applying to that Combination  must  provide a non-null value for that\nParameter, or the whole Combination is invalid. This is used by a Numerical\nModel, for instance, to require a value for an essential Parameter; it could\nprovide a Placeholder entry for  SETTING_FINAL_TIMESTEP , thereby ensuring any\nCombination incorporating it must have  SETTING_FINAL_TIMESTEP  provided by\nanother component, say, a Protocol.  It is possible for a Parameter Attribution to specify slightly more flexible\nbehaviour in this case - this is defined by a Parameter Attribution enum field.\nInstead of barring the formation of the Combination, it could prompt the\nsimulating user with an interactive widget when the Combination is used. Bear in\nmind, particularly in a medical setting, that this may be a clinician and not a\ntechnical user.  Concrete Parameters  When a Simulation is to be run, all of the Parameter Attributions applying to\nits Combination\nare grouped. A hierarchical algorithm picks one Parameter Attribution for each\nParameter that appears. Any Parameters that has a placeholder but no\nvalue-supplying Parameter Attributions must be given values by the end-user. For\nthis purpose, Parameter Attributions (so the placeholder) have a  widget  field.\nThe exact choices in rendering this are the responsibility of the UI.  This  attribution selection  creates an entity, a variation of\nParameter tied to a Simulation with a unique set of field values provided by the\nwinning Parameter Attribution (or user) - this is refered to as a  Concrete\nParameter  and corresponds to the Parameter concept as seen by the  simulation\nserver .  The Concrete Parameters for a simulation appear in the  GSSA-XML \nin the following format:  parameters \n     parameter name= PARAMNAME  value= PARAMATTRVALUE  type= PARAMATTRTYPE  / \n    ... /parameters   The  PARAMATTRTYPE  defines the type of  PARRAMATTRVALUE  and should be a type\nas described in the  Parameter types  section.", 
            "title": "Parameter Attributions"
        }, 
        {
            "location": "/server/overview/", 
            "text": "Go-Smart Simulation Architecture - Simulation Server\n\n\nOne or more simulation servers attach to the WAMP router and handle new\nsimulation requests. More than one may run on a machine and, as the simulations\nare launched as one or more separate processes, there is no necessarily\ncorrelation between servers and processes.\n\n\nEach server should have a unique ID (by default, a UUID). This may persist\nthrough restarts by passing it as an argument to\n\ngo-smart-simulation-server\n, the\nentry-point for the simulation server. This also refers to the server-side\nsimulation \ndatabase\n and re-using the ID will allow the simulation\nto maintain awareness of pre-existing simulations after restart.\n\n\nThe server is controlled via WAMP calls and, to enable discovery, is subscribed to\ncertain Pub-Sub\nnotifications. Any client permitted on the WAMP router may manipulate it, so\nprotection should be put in accordingly, especially until access control is\nestablished here.\n\n\nAs with \nGSSF\n, the GSSA server will\nregister with \nvigilant\n if it finds it.\nHowever, this has not been fully tested, and is not part of our current use case;\nit will be more extensively documented when proved reliable.\n\n\nControlling the server\n\n\nThe simulation server is controlled via WAMP. This requires a \nWAMP\nrouter\n, to which the server and client both connect.\n\nWAMP\n is a\nprotocol providing RPC (remote procedure call) and Pub-Sub\n(publisher-subscriber) support. Both communication patterns are used by the\nGSSA server. To provide the server-side WAMP session, the\n\nAutobahn\n libraries are used.\n\n\nOn start-up, the server registers a series of RPC methods:\n\n\n\n\n\n\n\n\nMethod\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ncom.gosmartsimulation.[ID].init(GUID)\n\n\nNotify server that a simulation will be set up (dummy method at present)\n\n\n\n\n\n\ncom.gosmartsimulation.[ID].start(GUID)\n\n\nBegin simulating simulation with given GUID\n\n\n\n\n\n\ncom.gosmartsimulation.[ID].update_settings_xml(GUID, XML)\n\n\nLoad the passed XML string as \nGSSA-XML\n for this simulation\n\n\n\n\n\n\ncom.gosmartsimulation.[ID].update_files(GUID, FILES)\n\n\nAdd the passed files map (basenames to remote locations relative to the transferrer) to the simulation's input file map\n\n\n\n\n\n\ncom.gosmartsimulation.[ID].request_files(GUID, FILES)\n\n\nSend the requested output files (basenames to remote locations relative to the transferrer)\n\n\n\n\n\n\ncom.gosmartsimulation.[ID].finalize(GUID)\n\n\nDo any remaining XML processing or file transferring, to be ready for the simulation to begin\n\n\n\n\n\n\ncom.gosmartsimulation.[ID].compare(XML1, XML2)\n\n\nCompare two GSSA-XML files and report the differences in a user readable list\n\n\n\n\n\n\ncom.gosmartsimulation.[ID].clean(GUID)\n\n\nRemove any server-side files related to this simulation, including the working directory\n\n\n\n\n\n\ncom.gosmartsimulation.[ID].properties(GUID)\n\n\nReturn a map of basic server-defined properties for this simulation (server-side working directory)\n\n\n\n\n\n\ncom.gosmartsimulation.[ID].retrieve_status(GUID)\n\n\nReturn the last known status of the simulation - this comprises most information held about a simulation, in a map\n\n\n\n\n\n\n\n\nThe \nID\n should be the ID of the simulation server. In addition, the first\nserver registered will add each call without the \n[ID].\n component, providing a\nglobal default on the WAMP router.\n\n\nThe server will also publish/subscribe the following notifications:\n\n\n\n\n\n\n\n\nOn Event\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ncom.gosmartsimulation.request_announce\n\n\nResponse\n: \ncom.gosmartsimulation.announce\n Does not expect arguments. For each simulation in the database, publishes with arguments: \n(server_id, simulation, (percentage, status), working_directory, last_status_timestamp, validation_xml)\n. Additionally, triggers an \nidentify\n response afterwards.\n\n\n\n\n\n\ncom.gosmartsimulation.request_identify\n\n\nResponse\n: \ncom.gosmartsimulation.identify\n Does not expect arguments. Responds by publishing \n(server_id, server_hostname, score)\n. The \nscore\n is the difference between the available processors and the number of active simulations in the database.\n\n\n\n\n\n\n\n\nEach server also subscribes to the same event with \n[ID].\n inserted before\n\nrequest\n, allowing targeted triggering of the same server response.\n\n\nIn addition to the responses above, a client may listen for the following\nevents:\n\n\n\n\n\n\n\n\nEvent\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ncom.gosmartsimulation.complete\n\n\nIndicates a simulation completion. Arguments: \n(simulation_id, SUCCESS_STATUS, working_directory, timestamp, validation_xml)\n\n\n\n\n\n\ncom.gosmartsimulation.fail\n\n\nIndicates a simulation failure. Arguments: \n(simulation_id, ERROR_STATUS, working_directory, timestamp, validation_xml)\n\n\n\n\n\n\ncom.gosmartsimulation.update_status\n\n\nIndicates a simulation failure. Arguments: \n(simulation_id, (percentage, PROGRESS_STATUS), working_directory, timestamp, validation_xml)\n\n\n\n\n\n\n\n\nNote that, with RPC calls, the server is configured to forward exceptions back\nto the client. In general, these should be \nerrors\n defined for GSSA,\nbut your client should recognise the possibility that they are unhandled\nserver-side errors and catch accordingly. If not a \nGoSmartError\n, this would indicate a bug-report\nshould be filed against GSSA.\n\n\nIt should be noted by authors of client-side applications that RPC, in\nparticular, needs care to implement - while the method calls reach specially\nprepared routines on the server-side, as the protocol is over a network, no\nguarantees are available about the completion of the call, the time for response or the integrity of the\ntransmission or reply, as might exist in the equivalent library API call. As\nsuch, appropriate error handling for exceptions from your WAMP library should be\nincorporated, and threading/timeouts set.\n\n\nConcurrency\n\n\nAs much as possible, any asynchronous behaviour has been mediated by\n\nasyncio\n\nusing \ncoroutines\n from the main thread. This includes simulation, meshing, WAMP\ninteractions, socket handling, database interaction and file transfers.", 
            "title": "Overview"
        }, 
        {
            "location": "/server/overview/#go-smart-simulation-architecture-simulation-server", 
            "text": "One or more simulation servers attach to the WAMP router and handle new\nsimulation requests. More than one may run on a machine and, as the simulations\nare launched as one or more separate processes, there is no necessarily\ncorrelation between servers and processes.  Each server should have a unique ID (by default, a UUID). This may persist\nthrough restarts by passing it as an argument to go-smart-simulation-server , the\nentry-point for the simulation server. This also refers to the server-side\nsimulation  database  and re-using the ID will allow the simulation\nto maintain awareness of pre-existing simulations after restart.  The server is controlled via WAMP calls and, to enable discovery, is subscribed to\ncertain Pub-Sub\nnotifications. Any client permitted on the WAMP router may manipulate it, so\nprotection should be put in accordingly, especially until access control is\nestablished here.  As with  GSSF , the GSSA server will\nregister with  vigilant  if it finds it.\nHowever, this has not been fully tested, and is not part of our current use case;\nit will be more extensively documented when proved reliable.", 
            "title": "Go-Smart Simulation Architecture - Simulation Server"
        }, 
        {
            "location": "/server/overview/#controlling-the-server", 
            "text": "The simulation server is controlled via WAMP. This requires a  WAMP\nrouter , to which the server and client both connect. WAMP  is a\nprotocol providing RPC (remote procedure call) and Pub-Sub\n(publisher-subscriber) support. Both communication patterns are used by the\nGSSA server. To provide the server-side WAMP session, the Autobahn  libraries are used.  On start-up, the server registers a series of RPC methods:     Method  Description      com.gosmartsimulation.[ID].init(GUID)  Notify server that a simulation will be set up (dummy method at present)    com.gosmartsimulation.[ID].start(GUID)  Begin simulating simulation with given GUID    com.gosmartsimulation.[ID].update_settings_xml(GUID, XML)  Load the passed XML string as  GSSA-XML  for this simulation    com.gosmartsimulation.[ID].update_files(GUID, FILES)  Add the passed files map (basenames to remote locations relative to the transferrer) to the simulation's input file map    com.gosmartsimulation.[ID].request_files(GUID, FILES)  Send the requested output files (basenames to remote locations relative to the transferrer)    com.gosmartsimulation.[ID].finalize(GUID)  Do any remaining XML processing or file transferring, to be ready for the simulation to begin    com.gosmartsimulation.[ID].compare(XML1, XML2)  Compare two GSSA-XML files and report the differences in a user readable list    com.gosmartsimulation.[ID].clean(GUID)  Remove any server-side files related to this simulation, including the working directory    com.gosmartsimulation.[ID].properties(GUID)  Return a map of basic server-defined properties for this simulation (server-side working directory)    com.gosmartsimulation.[ID].retrieve_status(GUID)  Return the last known status of the simulation - this comprises most information held about a simulation, in a map     The  ID  should be the ID of the simulation server. In addition, the first\nserver registered will add each call without the  [ID].  component, providing a\nglobal default on the WAMP router.  The server will also publish/subscribe the following notifications:     On Event  Description      com.gosmartsimulation.request_announce  Response :  com.gosmartsimulation.announce  Does not expect arguments. For each simulation in the database, publishes with arguments:  (server_id, simulation, (percentage, status), working_directory, last_status_timestamp, validation_xml) . Additionally, triggers an  identify  response afterwards.    com.gosmartsimulation.request_identify  Response :  com.gosmartsimulation.identify  Does not expect arguments. Responds by publishing  (server_id, server_hostname, score) . The  score  is the difference between the available processors and the number of active simulations in the database.     Each server also subscribes to the same event with  [ID].  inserted before request , allowing targeted triggering of the same server response.  In addition to the responses above, a client may listen for the following\nevents:     Event  Description      com.gosmartsimulation.complete  Indicates a simulation completion. Arguments:  (simulation_id, SUCCESS_STATUS, working_directory, timestamp, validation_xml)    com.gosmartsimulation.fail  Indicates a simulation failure. Arguments:  (simulation_id, ERROR_STATUS, working_directory, timestamp, validation_xml)    com.gosmartsimulation.update_status  Indicates a simulation failure. Arguments:  (simulation_id, (percentage, PROGRESS_STATUS), working_directory, timestamp, validation_xml)     Note that, with RPC calls, the server is configured to forward exceptions back\nto the client. In general, these should be  errors  defined for GSSA,\nbut your client should recognise the possibility that they are unhandled\nserver-side errors and catch accordingly. If not a  GoSmartError , this would indicate a bug-report\nshould be filed against GSSA.  It should be noted by authors of client-side applications that RPC, in\nparticular, needs care to implement - while the method calls reach specially\nprepared routines on the server-side, as the protocol is over a network, no\nguarantees are available about the completion of the call, the time for response or the integrity of the\ntransmission or reply, as might exist in the equivalent library API call. As\nsuch, appropriate error handling for exceptions from your WAMP library should be\nincorporated, and threading/timeouts set.", 
            "title": "Controlling the server"
        }, 
        {
            "location": "/server/overview/#concurrency", 
            "text": "As much as possible, any asynchronous behaviour has been mediated by asyncio \nusing  coroutines  from the main thread. This includes simulation, meshing, WAMP\ninteractions, socket handling, database interaction and file transfers.", 
            "title": "Concurrency"
        }, 
        {
            "location": "/server/router/", 
            "text": "Go-Smart Simulation Architecture - WAMP Router\n\n\nThe simulation server and client relate to each other through a WAMP server. For\nthis purpose, we recommend \nCrossbar\n and have provided\nsample configuration within the GSSA source tree (in the \nweb/\n subdirectory).\n\n\nThis allows direct interaction between clients of various languages (JS, Python and\nC# have been used) with the Python server.", 
            "title": "Router"
        }, 
        {
            "location": "/server/router/#go-smart-simulation-architecture-wamp-router", 
            "text": "The simulation server and client relate to each other through a WAMP server. For\nthis purpose, we recommend  Crossbar  and have provided\nsample configuration within the GSSA source tree (in the  web/  subdirectory).  This allows direct interaction between clients of various languages (JS, Python and\nC# have been used) with the Python server.", 
            "title": "Go-Smart Simulation Architecture - WAMP Router"
        }, 
        {
            "location": "/server/executables/", 
            "text": "Executables\n\n\ngo-smart-simulation-server\n\n\nThis is the simulation server script itself. You are expected to have a full\nworking installation of GSSA for this to behave as described, including GSSF and\nDocker if you wish to run such workflows.\n\n\ngo-smart-simulation-server [-h] [--host HOST]\n                              [--websocket-port WEBSOCKET_PORT]\n                              [--sftp-host SFTP_HOST]\n                              [--sftp-port SFTP_PORT]\n                              [--key-file KEY_FILE] [--ignore-development]\n                              [sid]\n\n\n\nPositional arguments\n\n\n\n\n\n\n\n\nArgument\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nsid\n\n\nServer UUID (should be subdirectory of current directory)\n\n\n\n\n\n\n\n\nOptional arguments\n\n\n\n\n\n\n\n\nArgument\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n-h, --help\n\n\nshow this help message and exit\n\n\n\n\n\n\n--host HOST\n\n\nhost to connect to\n\n\n\n\n\n\n--websocket-port WEBSOCKET_PORT\n\n\nport hosting websocket\n\n\n\n\n\n\n--sftp-host SFTP_HOST\n\n\nserver hosting SFTP\n\n\n\n\n\n\n--sftp-port SFTP_PORT\n\n\nport hosting SFTP\n\n\n\n\n\n\n--key-file KEY_FILE\n\n\nfile for authenticating to SFTP\n\n\n\n\n\n\n--ignore-development\n\n\ndo not process cases with parameter DEVELOPMENT truthy\n\n\n\n\n\n\n\n\ngo-smart-simulation-client\n\n\nThis is primarily a testing script for the server, but is capable of delivering\na GSSA-XML to any registered GSSA server via the named WAMP router.\n\n\ngo-smart-simulation-client [-h] [--gssa-file GSSA_FILE]\n                              [--subdir SUBDIR] [--host HOST]\n                              [--websocket-port WEBSOCKET_PORT]\n                              [--skip-clean]\n                              [--output OUTPUT [OUTPUT ...]]\n                              [--definition DEFINITION [DEFINITION ...]]\n                              [--input INPUT [INPUT ...]]\n                              [--server SERVER]\n\n\n\nOptional arguments\n\n\n\n\n\n\n\n\nArgument\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n-h, --help\n\n\nshow this help message and exit\n\n\n\n\n\n\n--gssa-file GSSA_FILE\n\n\nGSSA-XML simulation description\n\n\n\n\n\n\n--subdir SUBDIR\n\n\nsubdirectory of /tmp containing input files\n\n\n\n\n\n\n--host HOST\n\n\nhost to connect to\n\n\n\n\n\n\n--websocket-port PORT\n\n\nport hosting websocket\n\n\n\n\n\n\n--skip-clean\n\n\ndo not clean up after run\n\n\n\n\n\n\n--output OUT [OUT ...]\n\n\nfile(s) to request as output\n\n\n\n\n\n\n--definition DEF [DEF ...]\n\n\nfile(s) containing module / text of the definition node\n(which should exist but be empty in the GSSA file)\n\n\n\n\n\n\n--input IN [IN ...]\n\n\ninput files for surfaces, etc.\n\n\n\n\n\n\n--server SERVER\n\n\nspecific server to contact (UUID)\n\n\n\n\n\n\n\n\nDescription\n\n\nThe client takes all of the definition files and wraps them in a TAR.GZ file,\nreferencing it in the \nGSSA-XML\n file. It also wraps the input\nsurfaces in a TAR.GZ file and adds it to a \ntmp\n-transferrer node (expected for\nthese local client-server interactions).", 
            "title": "Executables"
        }, 
        {
            "location": "/server/executables/#executables", 
            "text": "", 
            "title": "Executables"
        }, 
        {
            "location": "/server/executables/#go-smart-simulation-server", 
            "text": "This is the simulation server script itself. You are expected to have a full\nworking installation of GSSA for this to behave as described, including GSSF and\nDocker if you wish to run such workflows.  go-smart-simulation-server [-h] [--host HOST]\n                              [--websocket-port WEBSOCKET_PORT]\n                              [--sftp-host SFTP_HOST]\n                              [--sftp-port SFTP_PORT]\n                              [--key-file KEY_FILE] [--ignore-development]\n                              [sid]  Positional arguments     Argument  Description      sid  Server UUID (should be subdirectory of current directory)     Optional arguments     Argument  Description      -h, --help  show this help message and exit    --host HOST  host to connect to    --websocket-port WEBSOCKET_PORT  port hosting websocket    --sftp-host SFTP_HOST  server hosting SFTP    --sftp-port SFTP_PORT  port hosting SFTP    --key-file KEY_FILE  file for authenticating to SFTP    --ignore-development  do not process cases with parameter DEVELOPMENT truthy", 
            "title": "go-smart-simulation-server"
        }, 
        {
            "location": "/server/executables/#go-smart-simulation-client", 
            "text": "This is primarily a testing script for the server, but is capable of delivering\na GSSA-XML to any registered GSSA server via the named WAMP router.  go-smart-simulation-client [-h] [--gssa-file GSSA_FILE]\n                              [--subdir SUBDIR] [--host HOST]\n                              [--websocket-port WEBSOCKET_PORT]\n                              [--skip-clean]\n                              [--output OUTPUT [OUTPUT ...]]\n                              [--definition DEFINITION [DEFINITION ...]]\n                              [--input INPUT [INPUT ...]]\n                              [--server SERVER]  Optional arguments     Argument  Description      -h, --help  show this help message and exit    --gssa-file GSSA_FILE  GSSA-XML simulation description    --subdir SUBDIR  subdirectory of /tmp containing input files    --host HOST  host to connect to    --websocket-port PORT  port hosting websocket    --skip-clean  do not clean up after run    --output OUT [OUT ...]  file(s) to request as output    --definition DEF [DEF ...]  file(s) containing module / text of the definition node (which should exist but be empty in the GSSA file)    --input IN [IN ...]  input files for surfaces, etc.    --server SERVER  specific server to contact (UUID)     Description  The client takes all of the definition files and wraps them in a TAR.GZ file,\nreferencing it in the  GSSA-XML  file. It also wraps the input\nsurfaces in a TAR.GZ file and adds it to a  tmp -transferrer node (expected for\nthese local client-server interactions).", 
            "title": "go-smart-simulation-client"
        }, 
        {
            "location": "/server/database/", 
            "text": "Go-Smart Simulation Server Database\n\n\nBy default, the GSSA server will create an \nSQLite\n\ndatabase to record past and present simulations, and their statuses. It is\nspecific to a server ID, so you can effectively resume a server by passing the\nsame ID to\n\ngo-smart-simulation-server\n.\n\n\nThe database records the following information:\n\n\n\n\n\n\n\n\nColumn\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nid\n\n\ninteger\n\n\nRow in the database, not the GUID of the simulation\n\n\n\n\n\n\nguid\n\n\nguid\n\n\nGUID of the simulation, as used by the client\n\n\n\n\n\n\ndirectory\n\n\ntext\n\n\nLocation of the simulation's (last known) working directory\n\n\n\n\n\n\nexit_code\n\n\ntext(null)\n\n\nError\n code on simulation exit\n\n\n\n\n\n\nstatus\n\n\ntext\n\n\nLast status update from the simulation\n\n\n\n\n\n\npercentage\n\n\nreal\n\n\nCompletion percentage\n\n\n\n\n\n\ntimestamp\n\n\nreal\n\n\nTime of last status update\n\n\n\n\n\n\nvalidation\n\n\ntext\n\n\nValidation XML\n\n\n\n\n\n\ncreated_at\n\n\ntimestamp\n\n\nEntry created\n\n\n\n\n\n\ndeleted\n\n\ntinyint\n\n\nSoft-deletion flag", 
            "title": "Database"
        }, 
        {
            "location": "/server/database/#go-smart-simulation-server-database", 
            "text": "By default, the GSSA server will create an  SQLite \ndatabase to record past and present simulations, and their statuses. It is\nspecific to a server ID, so you can effectively resume a server by passing the\nsame ID to go-smart-simulation-server .  The database records the following information:     Column  Type  Description      id  integer  Row in the database, not the GUID of the simulation    guid  guid  GUID of the simulation, as used by the client    directory  text  Location of the simulation's (last known) working directory    exit_code  text(null)  Error  code on simulation exit    status  text  Last status update from the simulation    percentage  real  Completion percentage    timestamp  real  Time of last status update    validation  text  Validation XML    created_at  timestamp  Entry created    deleted  tinyint  Soft-deletion flag", 
            "title": "Go-Smart Simulation Server Database"
        }, 
        {
            "location": "/server/transferrers/", 
            "text": "Transferrers\n\n\nThese are classes that handle moving of input files (other than GSSA-XML) back\nand forward from the simulation server to the client. This is configured using a\nsecond-level \ntransferrer/\n section in the \nGSSA-XML\n. The\ncurrent set of transferrers assume that the medium is secure (network or local\nmachine) - this will be\npartially improved with the reinstating of SFTPTransferrer, but alternative\nmethods should be added.\n\n\nHTTP Transferrer\n\n\nThis class defines means for transferring input files to and from the client\nusing HTTP.\n\n\nConfiguration\n\n\nThe \nHTTPTransferrer\n class is configured as follows:\n\n\n    \ntransferrer method=\nhttp\n\n        \nurl\nSOURCEURL\n/url\n\n      [ \noutput\nDESTINATIONURL\n/output\n ]\n    \n/transferrer\n\n\n\n\n\nIf the \noutput\n node is not present, the system will write output to \n/tmp\n.\nThis is primarily useful for debugging purposes.\n\n\nTmp Transferrer\n\n\nThis class, primarily useful for debugging, allows transfer of files through\n\n/tmp\n. It is particularly useful in conjunction with\n\ngo-smart-simulation-client\n.\n\n\nConfiguration\n\n\nThe \nTmpTransferrer\n class is configured as follows:\n\n\n    \ntransferrer method=\ntmp\n\n        \ninput location=\nLOCATION\n /\n\n    \n/trasferrer\n\n\n\n\n\nThe \nLOCATION\n should be an absolute path to a TAR.GZ archive of the input\nfiles, normally in \n/tmp\n. If it is not specified, the transferrer assumes the\nrelevant files are unzipped under \n/tmp/{remote_root}\n.\n\n\nSFTP Transferrer\n\n\nTODO\n: this has become out-of-date and needs updated before it is usable.", 
            "title": "Transferrers"
        }, 
        {
            "location": "/server/transferrers/#transferrers", 
            "text": "These are classes that handle moving of input files (other than GSSA-XML) back\nand forward from the simulation server to the client. This is configured using a\nsecond-level  transferrer/  section in the  GSSA-XML . The\ncurrent set of transferrers assume that the medium is secure (network or local\nmachine) - this will be\npartially improved with the reinstating of SFTPTransferrer, but alternative\nmethods should be added.", 
            "title": "Transferrers"
        }, 
        {
            "location": "/server/transferrers/#http-transferrer", 
            "text": "This class defines means for transferring input files to and from the client\nusing HTTP.  Configuration  The  HTTPTransferrer  class is configured as follows:       transferrer method= http \n         url SOURCEURL /url \n      [  output DESTINATIONURL /output  ]\n     /transferrer   If the  output  node is not present, the system will write output to  /tmp .\nThis is primarily useful for debugging purposes.", 
            "title": "HTTP Transferrer"
        }, 
        {
            "location": "/server/transferrers/#tmp-transferrer", 
            "text": "This class, primarily useful for debugging, allows transfer of files through /tmp . It is particularly useful in conjunction with go-smart-simulation-client .  Configuration  The  TmpTransferrer  class is configured as follows:       transferrer method= tmp \n         input location= LOCATION  / \n     /trasferrer   The  LOCATION  should be an absolute path to a TAR.GZ archive of the input\nfiles, normally in  /tmp . If it is not specified, the transferrer assumes the\nrelevant files are unzipped under  /tmp/{remote_root} .", 
            "title": "Tmp Transferrer"
        }, 
        {
            "location": "/server/transferrers/#sftp-transferrer", 
            "text": "TODO : this has become out-of-date and needs updated before it is usable.", 
            "title": "SFTP Transferrer"
        }, 
        {
            "location": "/docker/overview/", 
            "text": "Go-Smart Simulation Architecture - Docker Workflows\n\n\nThis workflow consists of a per-\nfamily\n Python module setting up\nconfiguration and a solver wrapped in a Docker image. Strictly, there are\ncurrently two Docker workflows: one entirely inside Docker and one using\n\nGSSF\n volumetric meshing prior to running a Docker instance.\n\n\nDefinition\n\n\nDefinitions for families in this workflow should include a \nstart.py\n file. This\nwill be called with Python2 (TODO: Python3) in an environment containing the\n\nPython container module\n.\n\n\nVariants\n\n\nDocker-only Workflow\n\n\nAny volumetric meshing must take place inside the Docker instance. This means\nthat the image must contain both a solver and a mesher (if meshing is required).\n\n\nDocker+CGAL Workflow\n\n\nThis hybrid scheme configures the \nGSSF mesher\n as would be the\ncase in \nGSSF\n, but stops after the volumetric\n(\nCGAL\n) meshing step. This \nMSH\n file is\nprovided as input to a simulation-only Docker instance. Combining these is\nachieved by use of a family mixin, a module that generates only\n\nmesher-cgal\n relevant parts of \nGSSF-XML\n,\n\ngssa.families.mesher_gssf.MesherGSSFMixin\n.\nThis is included into, for instance, \ngssa.families.fenics.FenicsFamily\n. (In\nfact, the same mix-in is used by GSSF itself for meshing configuration).", 
            "title": "Overview"
        }, 
        {
            "location": "/docker/overview/#go-smart-simulation-architecture-docker-workflows", 
            "text": "This workflow consists of a per- family  Python module setting up\nconfiguration and a solver wrapped in a Docker image. Strictly, there are\ncurrently two Docker workflows: one entirely inside Docker and one using GSSF  volumetric meshing prior to running a Docker instance.", 
            "title": "Go-Smart Simulation Architecture - Docker Workflows"
        }, 
        {
            "location": "/docker/overview/#definition", 
            "text": "Definitions for families in this workflow should include a  start.py  file. This\nwill be called with Python2 (TODO: Python3) in an environment containing the Python container module .", 
            "title": "Definition"
        }, 
        {
            "location": "/docker/overview/#variants", 
            "text": "Docker-only Workflow  Any volumetric meshing must take place inside the Docker instance. This means\nthat the image must contain both a solver and a mesher (if meshing is required).  Docker+CGAL Workflow  This hybrid scheme configures the  GSSF mesher  as would be the\ncase in  GSSF , but stops after the volumetric\n( CGAL ) meshing step. This  MSH  file is\nprovided as input to a simulation-only Docker instance. Combining these is\nachieved by use of a family mixin, a module that generates only mesher-cgal  relevant parts of  GSSF-XML , gssa.families.mesher_gssf.MesherGSSFMixin .\nThis is included into, for instance,  gssa.families.fenics.FenicsFamily . (In\nfact, the same mix-in is used by GSSF itself for meshing configuration).", 
            "title": "Variants"
        }, 
        {
            "location": "/docker/container-module/", 
            "text": "Go-Smart Simulation Architecture - Python Docker Container Module", 
            "title": "Python Container Module"
        }, 
        {
            "location": "/docker/container-module/#go-smart-simulation-architecture-python-docker-container-module", 
            "text": "", 
            "title": "Go-Smart Simulation Architecture - Python Docker Container Module"
        }, 
        {
            "location": "/docker/fenics/", 
            "text": "Go-Smart Simulation Architecture - FEniCS Family\n\n\nThis is a family within the \nDocker+CGAL\nworkflow\n, incorporating meshing from\n\nmesher-cgal\n and simulation provided by\n\nFEniCS\n. FEniCS is a general-purpose finite element\nframework, capable of automated solution of PDEs.\n\n\nThe\n\ndolfin-convert\n\nscript is used to translate the volumetric \nMSH\n into\nDOLFIN-XML, for direct import into the Python script. The reference upstream Docker\nimage for this is\n\nfenicsproject/stable-ppa\n.\n\n\nDefinition\n\n\nThe definition used for this family should be one or a series of Python files,\ncontaining a \nstart.py\n. This has access to all the FEniCS dependencies,\nincluding many core scientific Python libraries.", 
            "title": "FEniCS Family"
        }, 
        {
            "location": "/docker/fenics/#go-smart-simulation-architecture-fenics-family", 
            "text": "This is a family within the  Docker+CGAL\nworkflow , incorporating meshing from mesher-cgal  and simulation provided by FEniCS . FEniCS is a general-purpose finite element\nframework, capable of automated solution of PDEs.  The dolfin-convert \nscript is used to translate the volumetric  MSH  into\nDOLFIN-XML, for direct import into the Python script. The reference upstream Docker\nimage for this is fenicsproject/stable-ppa .", 
            "title": "Go-Smart Simulation Architecture - FEniCS Family"
        }, 
        {
            "location": "/docker/fenics/#definition", 
            "text": "The definition used for this family should be one or a series of Python files,\ncontaining a  start.py . This has access to all the FEniCS dependencies,\nincluding many core scientific Python libraries.", 
            "title": "Definition"
        }
    ]
}