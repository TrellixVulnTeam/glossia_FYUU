{
    "docs": [
        {
            "location": "/", 
            "text": "Welcome to MkDocs\n\n\nFor full documentation visit \nmkdocs.org\n.\n\n\nCommands\n\n\n\n\nmkdocs new [dir-name]\n - Create a new project.\n\n\nmkdocs serve\n - Start the live-reloading docs server.\n\n\nmkdocs build\n - Build the documentation site.\n\n\nmkdocs help\n - Print this help message.\n\n\n\n\nProject layout\n\n\nmkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.", 
            "title": "Home"
        }, 
        {
            "location": "/#welcome-to-mkdocs", 
            "text": "For full documentation visit  mkdocs.org .", 
            "title": "Welcome to MkDocs"
        }, 
        {
            "location": "/#commands", 
            "text": "mkdocs new [dir-name]  - Create a new project.  mkdocs serve  - Start the live-reloading docs server.  mkdocs build  - Build the documentation site.  mkdocs help  - Print this help message.", 
            "title": "Commands"
        }, 
        {
            "location": "/#project-layout", 
            "text": "mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.", 
            "title": "Project layout"
        }, 
        {
            "location": "/about/", 
            "text": "", 
            "title": "About"
        }, 
        {
            "location": "/comparison/", 
            "text": "Comparison of GSSA-XML documents\n\n\nThis tool allows diff-ing of two XML documents based on their conceptual content\nand returning a human-readable comparison.\n\n\ngo-smart-comparator\n\n\nThis is a simple wrapper script taking two GSSA-XML files and outputting the\ndifference in human-readable format.\n\n\nUsage\n\n\nThe script takes only two arguments: the files to be compared.\n\n\ngo-smart-comparator file1.xml file2.xml\n\n\n\nMethodology\n\n\nThe \ngssa.comparator\n module loads each file into a\n\nSimulationDefinition\n object, which has a \nCDM\n-based understanding\nof its content. Moreover, it is capable of diffing itself against another\n\nSimulationDefinition\n. The \nSimulationDefinition\n of the first file passed\nto the \nComparator\n object (the first file argument to\n\ngo-smart-comparator\n) is given the \nSimulationDefinition\n of the second. It\nreturns the description of the difference referring to itself as \nleft\n or\n\nthis\n and the other as \nright\n or \nthat\n.\n\n\nNote that the comparator is unable to account for non-embedded detail, such as\ngeometry files of the same name, differences of solver version and numerical\nmodels with a separately passed definition.", 
            "title": "Comparison"
        }, 
        {
            "location": "/comparison/#comparison-of-gssa-xml-documents", 
            "text": "This tool allows diff-ing of two XML documents based on their conceptual content\nand returning a human-readable comparison.", 
            "title": "Comparison of GSSA-XML documents"
        }, 
        {
            "location": "/comparison/#go-smart-comparator", 
            "text": "This is a simple wrapper script taking two GSSA-XML files and outputting the\ndifference in human-readable format.  Usage  The script takes only two arguments: the files to be compared.  go-smart-comparator file1.xml file2.xml", 
            "title": "go-smart-comparator"
        }, 
        {
            "location": "/comparison/#methodology", 
            "text": "The  gssa.comparator  module loads each file into a SimulationDefinition  object, which has a  CDM -based understanding\nof its content. Moreover, it is capable of diffing itself against another SimulationDefinition . The  SimulationDefinition  of the first file passed\nto the  Comparator  object (the first file argument to go-smart-comparator ) is given the  SimulationDefinition  of the second. It\nreturns the description of the difference referring to itself as  left  or this  and the other as  right  or  that .  Note that the comparator is unable to account for non-embedded detail, such as\ngeometry files of the same name, differences of solver version and numerical\nmodels with a separately passed definition.", 
            "title": "Methodology"
        }, 
        {
            "location": "/errors/", 
            "text": "Error types\n\n\nVery basic unified error types are provided, to help distinguish between user\nerrors, programmer errors, modeller errors and errors of unknown responsibility.\n\n\nThese contain codes which can be matched by the client-side tools. In theory,\nall errors returned from GSSA (and many from GSSF) will be one of these. Any\nerrors thrown beneath will be caught and wrapped accordingly.\n\n\nThese are passed back across WAMP to the client, which is why we do not wish to\npass arbitrary exceptions from Python server-side routines.\n\n\n\n\n\n\n\n\nError Code\n\n\nError ID\n\n\nIntepretation\n\n\nGSSF exception class (if app.)\n\n\n\n\n\n\n\n\n\n\nSUCCESS\n\n\n0\n\n\nAll worked\n\n\n-\n\n\n\n\n\n\nE_UNKNOWN\n\n\n1\n\n\nError of unknown origin\n\n\nGoSmartError\n\n\n\n\n\n\nE_CLIENT\n\n\n2\n\n\nTriggered by an issue on the client side, such as illogical input\n\n\nGoSmartClientError\n\n\n\n\n\n\nE_SERVER\n\n\n3\n\n\nProblems with the server or server-side tools\n\n\nGoSmartServerError\n\n\n\n\n\n\nE_MODEL\n\n\n4\n\n\nModelling problem, where the server cannot complete the task for physical/mathematical/numerical/syntactical reasons that are the responsibility of the model developer\n\n\nGoSmartModelError\n\n\n\n\n\n\n\n\nIn general, we err on the side of caution and attribute anything uncertain to\n\nE_SERVER\n or \nE_UNKNOWN\n. However, it may be, in the future, that being less\nconservative with \nE_MODEL\n will help provide automatic feedback on issues.", 
            "title": "Errors"
        }, 
        {
            "location": "/errors/#error-types", 
            "text": "Very basic unified error types are provided, to help distinguish between user\nerrors, programmer errors, modeller errors and errors of unknown responsibility.  These contain codes which can be matched by the client-side tools. In theory,\nall errors returned from GSSA (and many from GSSF) will be one of these. Any\nerrors thrown beneath will be caught and wrapped accordingly.  These are passed back across WAMP to the client, which is why we do not wish to\npass arbitrary exceptions from Python server-side routines.     Error Code  Error ID  Intepretation  GSSF exception class (if app.)      SUCCESS  0  All worked  -    E_UNKNOWN  1  Error of unknown origin  GoSmartError    E_CLIENT  2  Triggered by an issue on the client side, such as illogical input  GoSmartClientError    E_SERVER  3  Problems with the server or server-side tools  GoSmartServerError    E_MODEL  4  Modelling problem, where the server cannot complete the task for physical/mathematical/numerical/syntactical reasons that are the responsibility of the model developer  GoSmartModelError     In general, we err on the side of caution and attribute anything uncertain to E_SERVER  or  E_UNKNOWN . However, it may be, in the future, that being less\nconservative with  E_MODEL  will help provide automatic feedback on issues.", 
            "title": "Error types"
        }, 
        {
            "location": "/gssa-xml/", 
            "text": "Go-Smart Simulation Architecture XML Format (GSSA-XML)\n\n\nNote\n: this is distinct from \nGSSF-XML\n.\n\n\nGSSA-XML is documented as an XML Schema in the \nschema\n directory of the source\ntree. However, to provide a human-readable resource, it is described also here:\n\n\nsimulationDefinition\n\n    \ntransferrer class=\n(http|tmp)\n\n        \n!-- See Transferrers documentation --\n\n    \n/transferrer\n\n    \nalgorithms\n\n        \n!-- See Algorithms documentation --\n\n    \n/algorithms\n\n    \nparameters\n\n        \n!-- See Parameters#concrete-parameters documentation --\n\n    \n/parameters\n\n    \nnumericalModel\n\n        \nneedles\n\n            \nneedle index=\nNIX\n class=\nNCL\n file=\nNFILE\n\n                \nparameters\n\n                    \n!-- See Parameters#concrete-parameters documentation --\n\n                \n/parameters\n\n            \n/needle\n\n            ...\n        \n/needles\n\n        \nregions\n\n            \nregion id=\nRID\n name=\nRNAME\n format=\nRFORMAT:(zone|surface|both)\n input=\nRINPUT\n groups=\nRGROUPS\n /\n\n            ...\n        \n/regions\n\n        \ndefinition name=\nDFAMILY\n [ file=\nDFILE\n ]\n\n            \n!-- Family-specific content (see documentation for each family) --\n\n        \n/definition\n\n    \n/numericalModel\n\n\n/simulationDefinition\n\n\n\n\n\nThe needle index, \nNIX\n, indicates the name by which this needle should be\nreferred to. They should be integers, ordering the needles contiguously. The\nclass, \nNCL\n, identifies how a needle should be incorporated into the simulation\nand should either be \nsolid-boundary\n or \nboundary\n. The exact needle definition\nis supplied by \nNFILE\n, which should be of the form \nlibrary:LIBRARYTYPE\n or\n\nfile:INPUTFILENAME.stl\n. Within each needle node is another list of\nneedle-specific parameters.\n\n\nEach region should have an \nRID\n that uniquely refers to them within the\nsimulation. The \nRNAME\n is a context-providing name that may be used, such as\n\norgan\n or \ntumour\n. A simple way to generate IDs is to add an ordinal index to\nthe name, e.g., \ntumour-1\n. The \nRFORMAT\n indicates how the region should be\ntreated, as a zone, surface or both (volumetric subdomain, boundary, or embedded\nboundary). The \nRINPUT\n is the filename of the STL or VTP input file defining the\nsurface. The collection of region groups of which this region is a member should\nbe specified in the \nRGROUPS\n field, joined by \"\n;\n\".\n\n\nThe definition \nDFAMILY\n selects the family that should handle the definition.\nNote that it may be provided as a TAR.GZ (allowing, for instance, Python\nmodules) using the \nDFILE\n attribute, but is otherwise the body of the\n\ndefinition\n tag itself.", 
            "title": "GSSA XML Format"
        }, 
        {
            "location": "/gssa-xml/#go-smart-simulation-architecture-xml-format-gssa-xml", 
            "text": "Note : this is distinct from  GSSF-XML .  GSSA-XML is documented as an XML Schema in the  schema  directory of the source\ntree. However, to provide a human-readable resource, it is described also here:  simulationDefinition \n     transferrer class= (http|tmp) \n         !-- See Transferrers documentation -- \n     /transferrer \n     algorithms \n         !-- See Algorithms documentation -- \n     /algorithms \n     parameters \n         !-- See Parameters#concrete-parameters documentation -- \n     /parameters \n     numericalModel \n         needles \n             needle index= NIX  class= NCL  file= NFILE \n                 parameters \n                     !-- See Parameters#concrete-parameters documentation -- \n                 /parameters \n             /needle \n            ...\n         /needles \n         regions \n             region id= RID  name= RNAME  format= RFORMAT:(zone|surface|both)  input= RINPUT  groups= RGROUPS  / \n            ...\n         /regions \n         definition name= DFAMILY  [ file= DFILE  ] \n             !-- Family-specific content (see documentation for each family) -- \n         /definition \n     /numericalModel  /simulationDefinition   The needle index,  NIX , indicates the name by which this needle should be\nreferred to. They should be integers, ordering the needles contiguously. The\nclass,  NCL , identifies how a needle should be incorporated into the simulation\nand should either be  solid-boundary  or  boundary . The exact needle definition\nis supplied by  NFILE , which should be of the form  library:LIBRARYTYPE  or file:INPUTFILENAME.stl . Within each needle node is another list of\nneedle-specific parameters.  Each region should have an  RID  that uniquely refers to them within the\nsimulation. The  RNAME  is a context-providing name that may be used, such as organ  or  tumour . A simple way to generate IDs is to add an ordinal index to\nthe name, e.g.,  tumour-1 . The  RFORMAT  indicates how the region should be\ntreated, as a zone, surface or both (volumetric subdomain, boundary, or embedded\nboundary). The  RINPUT  is the filename of the STL or VTP input file defining the\nsurface. The collection of region groups of which this region is a member should\nbe specified in the  RGROUPS  field, joined by \" ; \".  The definition  DFAMILY  selects the family that should handle the definition.\nNote that it may be provided as a TAR.GZ (allowing, for instance, Python\nmodules) using the  DFILE  attribute, but is otherwise the body of the definition  tag itself.", 
            "title": "Go-Smart Simulation Architecture XML Format (GSSA-XML)"
        }, 
        {
            "location": "/families/", 
            "text": "Go-Smart Simulation Model Families\n\n\nFamilies represent groups of workflows that are simulated in approximately the\nsame way, or at least by using the same tools. This is slightly more specific\nthan a workflow as, for example, the Docker workflow has a separate family for\neach Docker image. It corresponds more accurately to a single configuration\nsystem. This comprises a pair: a subclass of \ngssa.family.Family\n\nthat contains instructions for interpreting \nGSSA-XML\n for this\ntype of simulation and writing any necessary tool-specific configuration files,\nand the simulation tools themselves.\n\n\nTwo examples are \nGSSF\n, which is also a fully fledged\nworkflow, and \nFEniCS\n, which depends on pre-meshing by\nthe \nGSSF CGAL mesher component\n.\n\n\nTo find families, the \ngssa.family\n module scans for files in the directory of\nthe \ngssa.families\n module. \nTODO\n: extend this to user-configurable locations.\n\n\nNote\n: family modules are run as part of the Python server - this means they\nare privileged and should only be included from highly \ntrusted\n sources, as\nwith other codes running as \nwww-data\n. They are not sandboxed or intended to be\nuser-supplied, but constitute a basic plug-in framework. The longer-term\nintention is to migrate to a proper plug-in framework, where community developed\nfamilies may be added in, running as an unprivileged user. Of course, this would\nstill require a higher level of trust than given to external user code, which\nonly runs sandboxed in Docker.", 
            "title": "Families"
        }, 
        {
            "location": "/families/#go-smart-simulation-model-families", 
            "text": "Families represent groups of workflows that are simulated in approximately the\nsame way, or at least by using the same tools. This is slightly more specific\nthan a workflow as, for example, the Docker workflow has a separate family for\neach Docker image. It corresponds more accurately to a single configuration\nsystem. This comprises a pair: a subclass of  gssa.family.Family \nthat contains instructions for interpreting  GSSA-XML  for this\ntype of simulation and writing any necessary tool-specific configuration files,\nand the simulation tools themselves.  Two examples are  GSSF , which is also a fully fledged\nworkflow, and  FEniCS , which depends on pre-meshing by\nthe  GSSF CGAL mesher component .  To find families, the  gssa.family  module scans for files in the directory of\nthe  gssa.families  module.  TODO : extend this to user-configurable locations.  Note : family modules are run as part of the Python server - this means they\nare privileged and should only be included from highly  trusted  sources, as\nwith other codes running as  www-data . They are not sandboxed or intended to be\nuser-supplied, but constitute a basic plug-in framework. The longer-term\nintention is to migrate to a proper plug-in framework, where community developed\nfamilies may be added in, running as an unprivileged user. Of course, this would\nstill require a higher level of trust than given to external user code, which\nonly runs sandboxed in Docker.", 
            "title": "Go-Smart Simulation Model Families"
        }, 
        {
            "location": "/cdm/overview/", 
            "text": "Go-Smart Clinical Domain Model\n\n\nThe Clinical\n\n\nAlgorithms", 
            "title": "Overview"
        }, 
        {
            "location": "/cdm/overview/#go-smart-clinical-domain-model", 
            "text": "The Clinical", 
            "title": "Go-Smart Clinical Domain Model"
        }, 
        {
            "location": "/cdm/overview/#algorithms", 
            "text": "", 
            "title": "Algorithms"
        }, 
        {
            "location": "/cdm/algorithms/", 
            "text": "Go-Smart Simulation Algorithms\n\n\nThese are members of the \nCDM\n that provide something akin to lambda\ncalculus to Go-Smart. They are database defined, have textual body in an\nunspecified language, return a parameter as a \nResult\n and take named arguments\nthat must be supplied by the numerical model as a condition of forming a valid\n\nCombination\n.\n\n\nDefinition\n\n\nThey can be defined in \nGSSA-XML\n, within the \nalgorithms /\n node\nas follows:\n\n\n    \nalgorithm result=\nRESULT\n\n        \narguments\n\n            \nargument name=\nARGNAME\n /\n\n        \n/arguments\n\n        \ncontent\n\n            ALGORITHMDEFINITION\n        \n/content\n\n    \n/algorithm\n\n\n\n\n\nThe \nALGORITHMDEFINITION\n may be defined in any language the simulation family\nwill understand (or, more accurately, the ultimate third-party simulation tool).\nExamples include MATC (for \nGSSF\n) and Python (for\n\nFEniCS\n). The \nRESULT\n is conventionally an upper-case,\nunderscore-spaced slug that can be used in place of a conventional \"constant\"\nparameter. Arguments are specified solely by name, not type (as we do not even\nknow the applicable language). They are expected to be supplied by the\nsimulation procedure at run-time.\n\n\nWhile this is no less secure than the numerical\nmodel running on the Docker instance from an administrator perspective, it should\nbe noted that the provenance of\nthe algorithm may well be different, and if the author of the numerical model (or\nDocker instance) is\nconcerned about data leakage from their instance, they should take adequate\nprecaution. Within the Python Docker module, the algorithm will not be called\nexcept as requested by the numerical module.", 
            "title": "Algorithms"
        }, 
        {
            "location": "/cdm/algorithms/#go-smart-simulation-algorithms", 
            "text": "These are members of the  CDM  that provide something akin to lambda\ncalculus to Go-Smart. They are database defined, have textual body in an\nunspecified language, return a parameter as a  Result  and take named arguments\nthat must be supplied by the numerical model as a condition of forming a valid Combination .", 
            "title": "Go-Smart Simulation Algorithms"
        }, 
        {
            "location": "/cdm/algorithms/#definition", 
            "text": "They can be defined in  GSSA-XML , within the  algorithms /  node\nas follows:       algorithm result= RESULT \n         arguments \n             argument name= ARGNAME  / \n         /arguments \n         content \n            ALGORITHMDEFINITION\n         /content \n     /algorithm   The  ALGORITHMDEFINITION  may be defined in any language the simulation family\nwill understand (or, more accurately, the ultimate third-party simulation tool).\nExamples include MATC (for  GSSF ) and Python (for FEniCS ). The  RESULT  is conventionally an upper-case,\nunderscore-spaced slug that can be used in place of a conventional \"constant\"\nparameter. Arguments are specified solely by name, not type (as we do not even\nknow the applicable language). They are expected to be supplied by the\nsimulation procedure at run-time.  While this is no less secure than the numerical\nmodel running on the Docker instance from an administrator perspective, it should\nbe noted that the provenance of\nthe algorithm may well be different, and if the author of the numerical model (or\nDocker instance) is\nconcerned about data leakage from their instance, they should take adequate\nprecaution. Within the Python Docker module, the algorithm will not be called\nexcept as requested by the numerical module.", 
            "title": "Definition"
        }, 
        {
            "location": "/cdm/contexts/", 
            "text": "Clinical-Domain Model - Contexts\n\n\nContexts\n are, normally, physical media in which a procedure takes place. They\nare often referred to as \nOrgans\n, but strictly, this need not be the case -\nphantoms or \nex vivo\n samples are valid Contexts.", 
            "title": "Contexts"
        }, 
        {
            "location": "/cdm/contexts/#clinical-domain-model-contexts", 
            "text": "Contexts  are, normally, physical media in which a procedure takes place. They\nare often referred to as  Organs , but strictly, this need not be the case -\nphantoms or  ex vivo  samples are valid Contexts.", 
            "title": "Clinical-Domain Model - Contexts"
        }, 
        {
            "location": "/cdm/parameters/", 
            "text": "Go-Smart Simulation Parameters\n\n\nParameters, within a \nCDM\n context, are entities uniquely\ndefined by their name, representing a value to be passed for simulation. This\ncould be a solver setting, a physical constant, a representation of clinician\nbehaviour over time, or essentially anything that can be encoded in a JSON\nobject. Interpretation, on the simulation side, is the responsibility of the\n\nfamily\n and/or the simulation tool. On the client side, it is the\nresponsibility of the UI engine to take the value and the widget definition and form a\nuseful interface.\n\n\nWhile a Parameter has a specific value, type and UI widget when concretized, that is,\nprepared for\na specific simulation, it may, in the abstract, have many \nParameter Attributions\n\neach attributing it to a different valid Combination, potentially with a different value,\ntype and UI widget each.\n\n\nParameter types\n\n\nThe Parameter type is specified in a string field. It should be lowercase,\nholding the name of a basic type (e.g. \nstring\n, \ninteger\n, \nboolean\n, \nfloat\n)\nor, if an array, it should be written \narray(BASICTYPE)\n where \nTYPE\n is\nthe type of elements of the array. If it is an array of tuples, it should be\nwritten \narray(BASICTYPE1, BASICTYPE2)\n, etc.\n\n\nParameter Attributions\n\n\nA \nParameter Attribution\n\nis an attachment record, linking a Parameter to another CDM entity, such as a\nNumerical Model or Needle. A Parameter Attribution has similar columns to a\nParameter, although not a name, instead referencing a ParameterId.\n\n\nParameter Attributions are matched to components in a limiting fashion. That is, a\nParameter Attribution can apply to a specific Numerical Model, or a specific\n(Numerical Model, Protocol) pair, or a specific (Numerical Model, Context, Needle)\ntriple, and so forth. A Parameter Attribution always applies to a Combination of\nentities \nunless\n at least one of the entities referenced in the Parameter\nAttribution is different\nto those named in the Combination. Consequently, a Parameter Attribution\nhaving no entity field filled in, will attribute a Parameter to all Combinations. (This may\nbe the case for universal constants, but is otherwise not especially useful).\n\n\nEach Parameter Attribution only be attributed to one specific component of\neach type. This does not prevent multiple otherwise identical Parameter\nAttributions from coexisting, each applying to a different Context, say.\n\n\nPlaceholders\n\n\nA Parameter Attribution with a null value is referred to as a Placeholder. When\nit applies to a given Combination, this\nindicates to the Combination-forming procedure that another Parameter\nAttribution applying to that Combination \nmust\n provide a non-null value for that\nParameter, or the whole Combination is invalid. This is used by a Numerical\nModel, for instance, to require a value for an essential Parameter; it could\nprovide a Placeholder entry for \nSETTING_FINAL_TIMESTEP\n, thereby ensuring any\nCombination incorporating it must have \nSETTING_FINAL_TIMESTEP\n provided by\nanother component, say, a Protocol.\n\n\nIt is possible for a Parameter Attribution to specify slightly more flexible\nbehaviour in this case - this is defined by a Parameter Attribution enum field.\nInstead of barring the formation of the Combination, it could prompt the\nsimulating user with an interactive widget when the Combination is used. Bear in\nmind, particularly in a medical setting, that this may be a clinician and not a\ntechnical user.\n\n\nConcrete Parameters\n\n\nWhen a Simulation is to be run, all of the Parameter Attributions applying to\nits Combination\nare grouped. A hierarchical algorithm picks one Parameter Attribution for each\nParameter that appears. Any Parameters that has a placeholder but no\nvalue-supplying Parameter Attributions must be given values by the end-user. For\nthis purpose, Parameter Attributions (so the placeholder) have a \nwidget\n field.\nThe exact choices in rendering this are the responsibility of the UI.\n\n\nThis \nattribution selection\n creates an entity, a variation of\nParameter tied to a Simulation with a unique set of field values provided by the\nwinning Parameter Attribution (or user) - this is refered to as a \nConcrete\nParameter\n and corresponds to the Parameter concept as seen by the \nsimulation\nserver\n.\n\n\nThe Concrete Parameters for a simulation appear in the \nGSSA-XML\n\nin the following format:\n\n\nparameters\n\n    \nparameter name=\nPARAMNAME\n value=\nPARAMATTRVALUE\n type=\nPARAMATTRTYPE\n /\n\n    ...\n\n/parameters\n\n\n\n\n\nThe \nPARAMATTRTYPE\n defines the type of \nPARRAMATTRVALUE\n and should be a type\nas described in the \nParameter types\n section.", 
            "title": "Parameters"
        }, 
        {
            "location": "/cdm/parameters/#go-smart-simulation-parameters", 
            "text": "Parameters, within a  CDM  context, are entities uniquely\ndefined by their name, representing a value to be passed for simulation. This\ncould be a solver setting, a physical constant, a representation of clinician\nbehaviour over time, or essentially anything that can be encoded in a JSON\nobject. Interpretation, on the simulation side, is the responsibility of the family  and/or the simulation tool. On the client side, it is the\nresponsibility of the UI engine to take the value and the widget definition and form a\nuseful interface.  While a Parameter has a specific value, type and UI widget when concretized, that is,\nprepared for\na specific simulation, it may, in the abstract, have many  Parameter Attributions \neach attributing it to a different valid Combination, potentially with a different value,\ntype and UI widget each.", 
            "title": "Go-Smart Simulation Parameters"
        }, 
        {
            "location": "/cdm/parameters/#parameter-types", 
            "text": "The Parameter type is specified in a string field. It should be lowercase,\nholding the name of a basic type (e.g.  string ,  integer ,  boolean ,  float )\nor, if an array, it should be written  array(BASICTYPE)  where  TYPE  is\nthe type of elements of the array. If it is an array of tuples, it should be\nwritten  array(BASICTYPE1, BASICTYPE2) , etc.", 
            "title": "Parameter types"
        }, 
        {
            "location": "/cdm/parameters/#parameter-attributions", 
            "text": "A  Parameter Attribution \nis an attachment record, linking a Parameter to another CDM entity, such as a\nNumerical Model or Needle. A Parameter Attribution has similar columns to a\nParameter, although not a name, instead referencing a ParameterId.  Parameter Attributions are matched to components in a limiting fashion. That is, a\nParameter Attribution can apply to a specific Numerical Model, or a specific\n(Numerical Model, Protocol) pair, or a specific (Numerical Model, Context, Needle)\ntriple, and so forth. A Parameter Attribution always applies to a Combination of\nentities  unless  at least one of the entities referenced in the Parameter\nAttribution is different\nto those named in the Combination. Consequently, a Parameter Attribution\nhaving no entity field filled in, will attribute a Parameter to all Combinations. (This may\nbe the case for universal constants, but is otherwise not especially useful).  Each Parameter Attribution only be attributed to one specific component of\neach type. This does not prevent multiple otherwise identical Parameter\nAttributions from coexisting, each applying to a different Context, say.  Placeholders  A Parameter Attribution with a null value is referred to as a Placeholder. When\nit applies to a given Combination, this\nindicates to the Combination-forming procedure that another Parameter\nAttribution applying to that Combination  must  provide a non-null value for that\nParameter, or the whole Combination is invalid. This is used by a Numerical\nModel, for instance, to require a value for an essential Parameter; it could\nprovide a Placeholder entry for  SETTING_FINAL_TIMESTEP , thereby ensuring any\nCombination incorporating it must have  SETTING_FINAL_TIMESTEP  provided by\nanother component, say, a Protocol.  It is possible for a Parameter Attribution to specify slightly more flexible\nbehaviour in this case - this is defined by a Parameter Attribution enum field.\nInstead of barring the formation of the Combination, it could prompt the\nsimulating user with an interactive widget when the Combination is used. Bear in\nmind, particularly in a medical setting, that this may be a clinician and not a\ntechnical user.  Concrete Parameters  When a Simulation is to be run, all of the Parameter Attributions applying to\nits Combination\nare grouped. A hierarchical algorithm picks one Parameter Attribution for each\nParameter that appears. Any Parameters that has a placeholder but no\nvalue-supplying Parameter Attributions must be given values by the end-user. For\nthis purpose, Parameter Attributions (so the placeholder) have a  widget  field.\nThe exact choices in rendering this are the responsibility of the UI.  This  attribution selection  creates an entity, a variation of\nParameter tied to a Simulation with a unique set of field values provided by the\nwinning Parameter Attribution (or user) - this is refered to as a  Concrete\nParameter  and corresponds to the Parameter concept as seen by the  simulation\nserver .  The Concrete Parameters for a simulation appear in the  GSSA-XML \nin the following format:  parameters \n     parameter name= PARAMNAME  value= PARAMATTRVALUE  type= PARAMATTRTYPE  / \n    ... /parameters   The  PARAMATTRTYPE  defines the type of  PARRAMATTRVALUE  and should be a type\nas described in the  Parameter types  section.", 
            "title": "Parameter Attributions"
        }, 
        {
            "location": "/server/overview/", 
            "text": "Go-Smart Simulation Architecture - Simulation Server\n\n\nOne or more simulation servers attach to the WAMP router and handle new\nsimulation requests. More than one may run on a machine and, as the simulations\nare launched as one or more separate processes, there is no necessarily\ncorrelation between servers and processes.\n\n\nEach server should have a unique ID (by default, a UUID). This may persist\nthrough restarts by passing it as an argument to\n\ngo-smart-simulation-server\n, the\nentry-point for the simulation server. This also refers to the server-side\nsimulation \ndatabase\n and re-using the ID will allow the simulation\nto maintain awareness of pre-existing simulations after restart.\n\n\nThe server is controlled via WAMP calls and, to enable discovery, is subscribed to\ncertain Pub-Sub\nnotifications. Any client permitted on the WAMP router may manipulate it, so\nprotection should be put in accordingly, especially until access control is\nestablished here.\n\n\nAs with \nGSSF\n, the GSSA server will\nregister with \nvigilant\n if it finds it.\nHowever, this has not been fully tested, and is not part of our current use case;\nit will be more extensively documented when proved reliable.\n\n\nControlling the server\n\n\nThe simulation server is controlled via WAMP. This requires a \nWAMP\nrouter\n, to which the server and client both connect.\n\nWAMP\n is a\nprotocol providing RPC (remote procedure call) and Pub-Sub\n(publisher-subscriber) support. Both communication patterns are used by the\nGSSA server. To provide the server-side WAMP session, the\n\nAutobahn\n libraries are used.\n\n\nOn start-up, the server registers a series of RPC methods:\n\n\n\n\n\n\n\n\nMethod\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ncom.gosmartsimulation.[ID].init(GUID)\n\n\nNotify server that a simulation will be set up (dummy method at present)\n\n\n\n\n\n\ncom.gosmartsimulation.[ID].start(GUID)\n\n\nBegin simulating simulation with given GUID\n\n\n\n\n\n\ncom.gosmartsimulation.[ID].update_settings_xml(GUID, XML)\n\n\nLoad the passed XML string as \nGSSA-XML\n for this simulation\n\n\n\n\n\n\ncom.gosmartsimulation.[ID].update_files(GUID, FILES)\n\n\nAdd the passed files map (basenames to remote locations relative to the transferrer) to the simulation's input file map\n\n\n\n\n\n\ncom.gosmartsimulation.[ID].request_files(GUID, FILES)\n\n\nSend the requested output files (basenames to remote locations relative to the transferrer)\n\n\n\n\n\n\ncom.gosmartsimulation.[ID].finalize(GUID)\n\n\nDo any remaining XML processing or file transferring, to be ready for the simulation to begin\n\n\n\n\n\n\ncom.gosmartsimulation.[ID].compare(XML1, XML2)\n\n\nCompare two GSSA-XML files and report the differences in a user readable list\n\n\n\n\n\n\ncom.gosmartsimulation.[ID].clean(GUID)\n\n\nRemove any server-side files related to this simulation, including the working directory\n\n\n\n\n\n\ncom.gosmartsimulation.[ID].properties(GUID)\n\n\nReturn a map of basic server-defined properties for this simulation (server-side working directory)\n\n\n\n\n\n\ncom.gosmartsimulation.[ID].retrieve_status(GUID)\n\n\nReturn the last known status of the simulation - this comprises most information held about a simulation, in a map\n\n\n\n\n\n\n\n\nThe \nID\n should be the ID of the simulation server. In addition, the first\nserver registered will add each call without the \n[ID].\n component, providing a\nglobal default on the WAMP router.\n\n\nThe server will also publish/subscribe the following notifications:\n\n\n\n\n\n\n\n\nOn Event\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ncom.gosmartsimulation.request_announce\n\n\nResponse\n: \ncom.gosmartsimulation.announce\n Does not expect arguments. For each simulation in the database, publishes with arguments: \n(server_id, simulation, (percentage, status), working_directory, last_status_timestamp, validation_xml)\n. Additionally, triggers an \nidentify\n response afterwards.\n\n\n\n\n\n\ncom.gosmartsimulation.request_identify\n\n\nResponse\n: \ncom.gosmartsimulation.identify\n Does not expect arguments. Responds by publishing \n(server_id, server_hostname, score)\n. The \nscore\n is the difference between the available processors and the number of active simulations in the database.\n\n\n\n\n\n\n\n\nEach server also subscribes to the same event with \n[ID].\n inserted before\n\nrequest\n, allowing targeted triggering of the same server response.\n\n\nIn addition to the responses above, a client may listen for the following\nevents:\n\n\n\n\n\n\n\n\nEvent\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ncom.gosmartsimulation.complete\n\n\nIndicates a simulation completion. Arguments: \n(simulation_id, SUCCESS_STATUS, working_directory, timestamp, validation_xml)\n\n\n\n\n\n\ncom.gosmartsimulation.fail\n\n\nIndicates a simulation failure. Arguments: \n(simulation_id, ERROR_STATUS, working_directory, timestamp, validation_xml)\n\n\n\n\n\n\ncom.gosmartsimulation.update_status\n\n\nIndicates a simulation failure. Arguments: \n(simulation_id, (percentage, PROGRESS_STATUS), working_directory, timestamp, validation_xml)\n\n\n\n\n\n\n\n\nNote that, with RPC calls, the server is configured to forward exceptions back\nto the client. In general, these should be \nerrors\n defined for GSSA,\nbut your client should recognise the possibility that they are unhandled\nserver-side errors and catch accordingly. If not a \nGoSmartError\n, this would indicate a bug-report\nshould be filed against GSSA.\n\n\nIt should be noted by authors of client-side applications that RPC, in\nparticular, needs care to implement - while the method calls reach specially\nprepared routines on the server-side, as the protocol is over a network, no\nguarantees are available about the completion of the call, the time for response or the integrity of the\ntransmission or reply, as might exist in the equivalent library API call. As\nsuch, appropriate error handling for exceptions from your WAMP library should be\nincorporated, and threading/timeouts set.\n\n\nConcurrency\n\n\nAs much as possible, any asynchronous behaviour has been mediated by\n\nasyncio\n\nusing \ncoroutines\n from the main thread. This includes simulation, meshing, WAMP\ninteractions, socket handling, database interaction and file transfers.", 
            "title": "Overview"
        }, 
        {
            "location": "/server/overview/#go-smart-simulation-architecture-simulation-server", 
            "text": "One or more simulation servers attach to the WAMP router and handle new\nsimulation requests. More than one may run on a machine and, as the simulations\nare launched as one or more separate processes, there is no necessarily\ncorrelation between servers and processes.  Each server should have a unique ID (by default, a UUID). This may persist\nthrough restarts by passing it as an argument to go-smart-simulation-server , the\nentry-point for the simulation server. This also refers to the server-side\nsimulation  database  and re-using the ID will allow the simulation\nto maintain awareness of pre-existing simulations after restart.  The server is controlled via WAMP calls and, to enable discovery, is subscribed to\ncertain Pub-Sub\nnotifications. Any client permitted on the WAMP router may manipulate it, so\nprotection should be put in accordingly, especially until access control is\nestablished here.  As with  GSSF , the GSSA server will\nregister with  vigilant  if it finds it.\nHowever, this has not been fully tested, and is not part of our current use case;\nit will be more extensively documented when proved reliable.", 
            "title": "Go-Smart Simulation Architecture - Simulation Server"
        }, 
        {
            "location": "/server/overview/#controlling-the-server", 
            "text": "The simulation server is controlled via WAMP. This requires a  WAMP\nrouter , to which the server and client both connect. WAMP  is a\nprotocol providing RPC (remote procedure call) and Pub-Sub\n(publisher-subscriber) support. Both communication patterns are used by the\nGSSA server. To provide the server-side WAMP session, the Autobahn  libraries are used.  On start-up, the server registers a series of RPC methods:     Method  Description      com.gosmartsimulation.[ID].init(GUID)  Notify server that a simulation will be set up (dummy method at present)    com.gosmartsimulation.[ID].start(GUID)  Begin simulating simulation with given GUID    com.gosmartsimulation.[ID].update_settings_xml(GUID, XML)  Load the passed XML string as  GSSA-XML  for this simulation    com.gosmartsimulation.[ID].update_files(GUID, FILES)  Add the passed files map (basenames to remote locations relative to the transferrer) to the simulation's input file map    com.gosmartsimulation.[ID].request_files(GUID, FILES)  Send the requested output files (basenames to remote locations relative to the transferrer)    com.gosmartsimulation.[ID].finalize(GUID)  Do any remaining XML processing or file transferring, to be ready for the simulation to begin    com.gosmartsimulation.[ID].compare(XML1, XML2)  Compare two GSSA-XML files and report the differences in a user readable list    com.gosmartsimulation.[ID].clean(GUID)  Remove any server-side files related to this simulation, including the working directory    com.gosmartsimulation.[ID].properties(GUID)  Return a map of basic server-defined properties for this simulation (server-side working directory)    com.gosmartsimulation.[ID].retrieve_status(GUID)  Return the last known status of the simulation - this comprises most information held about a simulation, in a map     The  ID  should be the ID of the simulation server. In addition, the first\nserver registered will add each call without the  [ID].  component, providing a\nglobal default on the WAMP router.  The server will also publish/subscribe the following notifications:     On Event  Description      com.gosmartsimulation.request_announce  Response :  com.gosmartsimulation.announce  Does not expect arguments. For each simulation in the database, publishes with arguments:  (server_id, simulation, (percentage, status), working_directory, last_status_timestamp, validation_xml) . Additionally, triggers an  identify  response afterwards.    com.gosmartsimulation.request_identify  Response :  com.gosmartsimulation.identify  Does not expect arguments. Responds by publishing  (server_id, server_hostname, score) . The  score  is the difference between the available processors and the number of active simulations in the database.     Each server also subscribes to the same event with  [ID].  inserted before request , allowing targeted triggering of the same server response.  In addition to the responses above, a client may listen for the following\nevents:     Event  Description      com.gosmartsimulation.complete  Indicates a simulation completion. Arguments:  (simulation_id, SUCCESS_STATUS, working_directory, timestamp, validation_xml)    com.gosmartsimulation.fail  Indicates a simulation failure. Arguments:  (simulation_id, ERROR_STATUS, working_directory, timestamp, validation_xml)    com.gosmartsimulation.update_status  Indicates a simulation failure. Arguments:  (simulation_id, (percentage, PROGRESS_STATUS), working_directory, timestamp, validation_xml)     Note that, with RPC calls, the server is configured to forward exceptions back\nto the client. In general, these should be  errors  defined for GSSA,\nbut your client should recognise the possibility that they are unhandled\nserver-side errors and catch accordingly. If not a  GoSmartError , this would indicate a bug-report\nshould be filed against GSSA.  It should be noted by authors of client-side applications that RPC, in\nparticular, needs care to implement - while the method calls reach specially\nprepared routines on the server-side, as the protocol is over a network, no\nguarantees are available about the completion of the call, the time for response or the integrity of the\ntransmission or reply, as might exist in the equivalent library API call. As\nsuch, appropriate error handling for exceptions from your WAMP library should be\nincorporated, and threading/timeouts set.", 
            "title": "Controlling the server"
        }, 
        {
            "location": "/server/overview/#concurrency", 
            "text": "As much as possible, any asynchronous behaviour has been mediated by asyncio \nusing  coroutines  from the main thread. This includes simulation, meshing, WAMP\ninteractions, socket handling, database interaction and file transfers.", 
            "title": "Concurrency"
        }, 
        {
            "location": "/server/router/", 
            "text": "Go-Smart Simulation Architecture - WAMP Router\n\n\nThe simulation server and client relate to each other through a WAMP server. For\nthis purpose, we recommend \nCrossbar\n and have provided\nsample configuration within the GSSA source tree (in the \nweb/\n subdirectory).\n\n\nThis allows direct interaction between clients of various languages (JS, Python and\nC# have been used) with the Python server.", 
            "title": "Router"
        }, 
        {
            "location": "/server/router/#go-smart-simulation-architecture-wamp-router", 
            "text": "The simulation server and client relate to each other through a WAMP server. For\nthis purpose, we recommend  Crossbar  and have provided\nsample configuration within the GSSA source tree (in the  web/  subdirectory).  This allows direct interaction between clients of various languages (JS, Python and\nC# have been used) with the Python server.", 
            "title": "Go-Smart Simulation Architecture - WAMP Router"
        }, 
        {
            "location": "/server/executables/", 
            "text": "Executables\n\n\ngo-smart-simulation-server\n\n\nThis is the simulation server script itself. You are expected to have a full\nworking installation of GSSA for this to behave as described, including GSSF and\nDocker if you wish to run such workflows.\n\n\ngo-smart-simulation-server [-h] [--host HOST]\n                              [--websocket-port WEBSOCKET_PORT]\n                              [--sftp-host SFTP_HOST]\n                              [--sftp-port SFTP_PORT]\n                              [--key-file KEY_FILE] [--ignore-development]\n                              [sid]\n\n\n\nPositional arguments\n\n\n\n\n\n\n\n\nArgument\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nsid\n\n\nServer UUID (should be subdirectory of current directory)\n\n\n\n\n\n\n\n\nOptional arguments\n\n\n\n\n\n\n\n\nArgument\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n-h, --help\n\n\nshow this help message and exit\n\n\n\n\n\n\n--host HOST\n\n\nhost to connect to\n\n\n\n\n\n\n--websocket-port WEBSOCKET_PORT\n\n\nport hosting websocket\n\n\n\n\n\n\n--sftp-host SFTP_HOST\n\n\nserver hosting SFTP\n\n\n\n\n\n\n--sftp-port SFTP_PORT\n\n\nport hosting SFTP\n\n\n\n\n\n\n--key-file KEY_FILE\n\n\nfile for authenticating to SFTP\n\n\n\n\n\n\n--ignore-development\n\n\ndo not process cases with parameter DEVELOPMENT truthy\n\n\n\n\n\n\n\n\ngo-smart-simulation-client\n\n\nThis is primarily a testing script for the server, but is capable of delivering\na GSSA-XML to any registered GSSA server via the named WAMP router.\n\n\ngo-smart-simulation-client [-h] [--gssa-file GSSA_FILE]\n                              [--subdir SUBDIR] [--host HOST]\n                              [--websocket-port WEBSOCKET_PORT]\n                              [--skip-clean]\n                              [--output OUTPUT [OUTPUT ...]]\n                              [--definition DEFINITION [DEFINITION ...]]\n                              [--input INPUT [INPUT ...]]\n                              [--server SERVER]\n\n\n\nOptional arguments\n\n\n\n\n\n\n\n\nArgument\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n-h, --help\n\n\nshow this help message and exit\n\n\n\n\n\n\n--gssa-file GSSA_FILE\n\n\nGSSA-XML simulation description\n\n\n\n\n\n\n--subdir SUBDIR\n\n\nsubdirectory of /tmp containing input files\n\n\n\n\n\n\n--host HOST\n\n\nhost to connect to\n\n\n\n\n\n\n--websocket-port PORT\n\n\nport hosting websocket\n\n\n\n\n\n\n--skip-clean\n\n\ndo not clean up after run\n\n\n\n\n\n\n--output OUT [OUT ...]\n\n\nfile(s) to request as output\n\n\n\n\n\n\n--definition DEF [DEF ...]\n\n\nfile(s) containing module / text of the definition node\n(which should exist but be empty in the GSSA file)\n\n\n\n\n\n\n--input IN [IN ...]\n\n\ninput files for surfaces, etc.\n\n\n\n\n\n\n--server SERVER\n\n\nspecific server to contact (UUID)\n\n\n\n\n\n\n\n\nDescription\n\n\nThe client takes all of the definition files and wraps them in a TAR.GZ file,\nreferencing it in the \nGSSA-XML\n file. It also wraps the input\nsurfaces in a TAR.GZ file and adds it to a \ntmp\n-transferrer node (expected for\nthese local client-server interactions).", 
            "title": "Executables"
        }, 
        {
            "location": "/server/executables/#executables", 
            "text": "", 
            "title": "Executables"
        }, 
        {
            "location": "/server/executables/#go-smart-simulation-server", 
            "text": "This is the simulation server script itself. You are expected to have a full\nworking installation of GSSA for this to behave as described, including GSSF and\nDocker if you wish to run such workflows.  go-smart-simulation-server [-h] [--host HOST]\n                              [--websocket-port WEBSOCKET_PORT]\n                              [--sftp-host SFTP_HOST]\n                              [--sftp-port SFTP_PORT]\n                              [--key-file KEY_FILE] [--ignore-development]\n                              [sid]  Positional arguments     Argument  Description      sid  Server UUID (should be subdirectory of current directory)     Optional arguments     Argument  Description      -h, --help  show this help message and exit    --host HOST  host to connect to    --websocket-port WEBSOCKET_PORT  port hosting websocket    --sftp-host SFTP_HOST  server hosting SFTP    --sftp-port SFTP_PORT  port hosting SFTP    --key-file KEY_FILE  file for authenticating to SFTP    --ignore-development  do not process cases with parameter DEVELOPMENT truthy", 
            "title": "go-smart-simulation-server"
        }, 
        {
            "location": "/server/executables/#go-smart-simulation-client", 
            "text": "This is primarily a testing script for the server, but is capable of delivering\na GSSA-XML to any registered GSSA server via the named WAMP router.  go-smart-simulation-client [-h] [--gssa-file GSSA_FILE]\n                              [--subdir SUBDIR] [--host HOST]\n                              [--websocket-port WEBSOCKET_PORT]\n                              [--skip-clean]\n                              [--output OUTPUT [OUTPUT ...]]\n                              [--definition DEFINITION [DEFINITION ...]]\n                              [--input INPUT [INPUT ...]]\n                              [--server SERVER]  Optional arguments     Argument  Description      -h, --help  show this help message and exit    --gssa-file GSSA_FILE  GSSA-XML simulation description    --subdir SUBDIR  subdirectory of /tmp containing input files    --host HOST  host to connect to    --websocket-port PORT  port hosting websocket    --skip-clean  do not clean up after run    --output OUT [OUT ...]  file(s) to request as output    --definition DEF [DEF ...]  file(s) containing module / text of the definition node (which should exist but be empty in the GSSA file)    --input IN [IN ...]  input files for surfaces, etc.    --server SERVER  specific server to contact (UUID)     Description  The client takes all of the definition files and wraps them in a TAR.GZ file,\nreferencing it in the  GSSA-XML  file. It also wraps the input\nsurfaces in a TAR.GZ file and adds it to a  tmp -transferrer node (expected for\nthese local client-server interactions).", 
            "title": "go-smart-simulation-client"
        }, 
        {
            "location": "/server/database/", 
            "text": "Go-Smart Simulation Server Database\n\n\nBy default, the GSSA server will create an \nSQLite\n\ndatabase to record past and present simulations, and their statuses. It is\nspecific to a server ID, so you can effectively resume a server by passing the\nsame ID to\n\ngo-smart-simulation-server\n.\n\n\nThe database records the following information:\n\n\n\n\n\n\n\n\nColumn\n\n\nType\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nid\n\n\ninteger\n\n\nRow in the database, not the GUID of the simulation\n\n\n\n\n\n\nguid\n\n\nguid\n\n\nGUID of the simulation, as used by the client\n\n\n\n\n\n\ndirectory\n\n\ntext\n\n\nLocation of the simulation's (last known) working directory\n\n\n\n\n\n\nexit_code\n\n\ntext(null)\n\n\nError\n code on simulation exit\n\n\n\n\n\n\nstatus\n\n\ntext\n\n\nLast status update from the simulation\n\n\n\n\n\n\npercentage\n\n\nreal\n\n\nCompletion percentage\n\n\n\n\n\n\ntimestamp\n\n\nreal\n\n\nTime of last status update\n\n\n\n\n\n\nvalidation\n\n\ntext\n\n\nValidation XML\n\n\n\n\n\n\ncreated_at\n\n\ntimestamp\n\n\nEntry created\n\n\n\n\n\n\ndeleted\n\n\ntinyint\n\n\nSoft-deletion flag", 
            "title": "Database"
        }, 
        {
            "location": "/server/database/#go-smart-simulation-server-database", 
            "text": "By default, the GSSA server will create an  SQLite \ndatabase to record past and present simulations, and their statuses. It is\nspecific to a server ID, so you can effectively resume a server by passing the\nsame ID to go-smart-simulation-server .  The database records the following information:     Column  Type  Description      id  integer  Row in the database, not the GUID of the simulation    guid  guid  GUID of the simulation, as used by the client    directory  text  Location of the simulation's (last known) working directory    exit_code  text(null)  Error  code on simulation exit    status  text  Last status update from the simulation    percentage  real  Completion percentage    timestamp  real  Time of last status update    validation  text  Validation XML    created_at  timestamp  Entry created    deleted  tinyint  Soft-deletion flag", 
            "title": "Go-Smart Simulation Server Database"
        }, 
        {
            "location": "/server/transferrers/", 
            "text": "Transferrers\n\n\nThese are classes that handle moving of input files (other than GSSA-XML) back\nand forward from the simulation server to the client. This is configured using a\nsecond-level \ntransferrer/\n section in the \nGSSA-XML\n. The\ncurrent set of transferrers assume that the medium is secure (network or local\nmachine) - this will be\npartially improved with the reinstating of SFTPTransferrer, but alternative\nmethods should be added.\n\n\nHTTP Transferrer\n\n\nThis class defines means for transferring input files to and from the client\nusing HTTP.\n\n\nConfiguration\n\n\nThe \nHTTPTransferrer\n class is configured as follows:\n\n\n    \ntransferrer method=\nhttp\n\n        \nurl\nSOURCEURL\n/url\n\n      [ \noutput\nDESTINATIONURL\n/output\n ]\n    \n/transferrer\n\n\n\n\n\nIf the \noutput\n node is not present, the system will write output to \n/tmp\n.\nThis is primarily useful for debugging purposes.\n\n\nTmp Transferrer\n\n\nThis class, primarily useful for debugging, allows transfer of files through\n\n/tmp\n. It is particularly useful in conjunction with\n\ngo-smart-simulation-client\n.\n\n\nConfiguration\n\n\nThe \nTmpTransferrer\n class is configured as follows:\n\n\n    \ntransferrer method=\ntmp\n\n        \ninput location=\nLOCATION\n /\n\n    \n/trasferrer\n\n\n\n\n\nThe \nLOCATION\n should be an absolute path to a TAR.GZ archive of the input\nfiles, normally in \n/tmp\n. If it is not specified, the transferrer assumes the\nrelevant files are unzipped under \n/tmp/{remote_root}\n.\n\n\nSFTP Transferrer\n\n\nTODO\n: this has become out-of-date and needs updated before it is usable.", 
            "title": "Transferrers"
        }, 
        {
            "location": "/server/transferrers/#transferrers", 
            "text": "These are classes that handle moving of input files (other than GSSA-XML) back\nand forward from the simulation server to the client. This is configured using a\nsecond-level  transferrer/  section in the  GSSA-XML . The\ncurrent set of transferrers assume that the medium is secure (network or local\nmachine) - this will be\npartially improved with the reinstating of SFTPTransferrer, but alternative\nmethods should be added.", 
            "title": "Transferrers"
        }, 
        {
            "location": "/server/transferrers/#http-transferrer", 
            "text": "This class defines means for transferring input files to and from the client\nusing HTTP.  Configuration  The  HTTPTransferrer  class is configured as follows:       transferrer method= http \n         url SOURCEURL /url \n      [  output DESTINATIONURL /output  ]\n     /transferrer   If the  output  node is not present, the system will write output to  /tmp .\nThis is primarily useful for debugging purposes.", 
            "title": "HTTP Transferrer"
        }, 
        {
            "location": "/server/transferrers/#tmp-transferrer", 
            "text": "This class, primarily useful for debugging, allows transfer of files through /tmp . It is particularly useful in conjunction with go-smart-simulation-client .  Configuration  The  TmpTransferrer  class is configured as follows:       transferrer method= tmp \n         input location= LOCATION  / \n     /trasferrer   The  LOCATION  should be an absolute path to a TAR.GZ archive of the input\nfiles, normally in  /tmp . If it is not specified, the transferrer assumes the\nrelevant files are unzipped under  /tmp/{remote_root} .", 
            "title": "Tmp Transferrer"
        }, 
        {
            "location": "/server/transferrers/#sftp-transferrer", 
            "text": "TODO : this has become out-of-date and needs updated before it is usable.", 
            "title": "SFTP Transferrer"
        }, 
        {
            "location": "/tools/mesher-cgal/", 
            "text": "CGAL Meshing Utility - mesher-cgal\n\n\nUpstream contribution\n\n\nCertain minor modifications to the CGAL core may be desirable upstream,\nparticularly those relating to surface marking during volumetric meshing. Most\naspects of mesher-cgal are context-specific, so unlikely to be suitable for\ninclusion in the CGAL project, but may be of use to other downstream users,\nindependently.", 
            "title": "CGAL Meshing (mesher-cgal)"
        }, 
        {
            "location": "/tools/mesher-cgal/#cgal-meshing-utility-mesher-cgal", 
            "text": "", 
            "title": "CGAL Meshing Utility - mesher-cgal"
        }, 
        {
            "location": "/tools/mesher-cgal/#upstream-contribution", 
            "text": "Certain minor modifications to the CGAL core may be desirable upstream,\nparticularly those relating to surface marking during volumetric meshing. Most\naspects of mesher-cgal are context-specific, so unlikely to be suitable for\ninclusion in the CGAL project, but may be of use to other downstream users,\nindependently.", 
            "title": "Upstream contribution"
        }, 
        {
            "location": "/docker/overview/", 
            "text": "Go-Smart Simulation Architecture - Docker Workflows\n\n\nThis workflow consists of a per-\nfamily\n Python module setting up\nconfiguration and a solver wrapped in a Docker image. Strictly, there are\ncurrently two Docker workflows: one entirely inside Docker and one using\n\nGSSF\n volumetric meshing prior to running a Docker instance.\n\n\nDefinition\n\n\nDefinitions for families in this workflow should include a \nstart.py\n file. This\nwill be called with Python2 (TODO: Python3) in an environment containing the\n\nPython container module\n.\n\n\nVariants\n\n\nDocker-only Workflow\n\n\nAny volumetric meshing must take place inside the Docker instance. This means\nthat the image must contain both a solver and a mesher (if meshing is required).\n\n\nDocker+CGAL Workflow\n\n\nThis hybrid scheme configures the \nGSSF mesher\n as would be the\ncase in \nGSSF\n, but stops after the volumetric\n(\nCGAL\n) meshing step. This \nMSH\n file is\nprovided as input to a simulation-only Docker instance. Combining these is\nachieved by use of a family mixin, a module that generates only\n\nmesher-cgal\n relevant parts of \nGSSF-XML\n,\n\ngssa.families.mesher_gssf.MesherGSSFMixin\n.\nThis is included into, for instance, \ngssa.families.fenics.FenicsFamily\n. (In\nfact, the same mix-in is used by GSSF itself for meshing configuration).", 
            "title": "Overview"
        }, 
        {
            "location": "/docker/overview/#go-smart-simulation-architecture-docker-workflows", 
            "text": "This workflow consists of a per- family  Python module setting up\nconfiguration and a solver wrapped in a Docker image. Strictly, there are\ncurrently two Docker workflows: one entirely inside Docker and one using GSSF  volumetric meshing prior to running a Docker instance.", 
            "title": "Go-Smart Simulation Architecture - Docker Workflows"
        }, 
        {
            "location": "/docker/overview/#definition", 
            "text": "Definitions for families in this workflow should include a  start.py  file. This\nwill be called with Python2 (TODO: Python3) in an environment containing the Python container module .", 
            "title": "Definition"
        }, 
        {
            "location": "/docker/overview/#variants", 
            "text": "Docker-only Workflow  Any volumetric meshing must take place inside the Docker instance. This means\nthat the image must contain both a solver and a mesher (if meshing is required).  Docker+CGAL Workflow  This hybrid scheme configures the  GSSF mesher  as would be the\ncase in  GSSF , but stops after the volumetric\n( CGAL ) meshing step. This  MSH  file is\nprovided as input to a simulation-only Docker instance. Combining these is\nachieved by use of a family mixin, a module that generates only mesher-cgal  relevant parts of  GSSF-XML , gssa.families.mesher_gssf.MesherGSSFMixin .\nThis is included into, for instance,  gssa.families.fenics.FenicsFamily . (In\nfact, the same mix-in is used by GSSF itself for meshing configuration).", 
            "title": "Variants"
        }, 
        {
            "location": "/docker/container-module/", 
            "text": "Go-Smart Simulation Architecture - Python Docker Container Module", 
            "title": "Python Container Module"
        }, 
        {
            "location": "/docker/container-module/#go-smart-simulation-architecture-python-docker-container-module", 
            "text": "", 
            "title": "Go-Smart Simulation Architecture - Python Docker Container Module"
        }, 
        {
            "location": "/docker/fenics/", 
            "text": "Go-Smart Simulation Architecture - FEniCS Family\n\n\nThis is a family within the \nDocker+CGAL\nworkflow\n, incorporating meshing from\n\nmesher-cgal\n and simulation provided by\n\nFEniCS\n. FEniCS is a general-purpose finite element\nframework, capable of automated solution of PDEs.\n\n\nThe\n\ndolfin-convert\n\nscript is used to translate the volumetric \nMSH\n into\nDOLFIN-XML, for direct import into the Python script. The reference upstream Docker\nimage for this is\n\nfenicsproject/stable-ppa\n.\n\n\nDefinition\n\n\nThe definition used for this family should be one or a series of Python files,\ncontaining a \nstart.py\n. This has access to all the FEniCS dependencies,\nincluding many core scientific Python libraries.", 
            "title": "FEniCS Family"
        }, 
        {
            "location": "/docker/fenics/#go-smart-simulation-architecture-fenics-family", 
            "text": "This is a family within the  Docker+CGAL\nworkflow , incorporating meshing from mesher-cgal  and simulation provided by FEniCS . FEniCS is a general-purpose finite element\nframework, capable of automated solution of PDEs.  The dolfin-convert \nscript is used to translate the volumetric  MSH  into\nDOLFIN-XML, for direct import into the Python script. The reference upstream Docker\nimage for this is fenicsproject/stable-ppa .", 
            "title": "Go-Smart Simulation Architecture - FEniCS Family"
        }, 
        {
            "location": "/docker/fenics/#definition", 
            "text": "The definition used for this family should be one or a series of Python files,\ncontaining a  start.py . This has access to all the FEniCS dependencies,\nincluding many core scientific Python libraries.", 
            "title": "Definition"
        }, 
        {
            "location": "/gssf/overview/", 
            "text": "Go-Smart Simulation Framework\n\n\nThe simulation framework (as opposed to the architecture) is a single specific\nworkflow that allows a user to provide a set of STL surfaces and Elmer\nconfiguration, and get back a lesion surface.\n\n\nThis workflow is based primarily on \nElmer FEM\n,\na Finite Element multiphysics package primarily developed by\n\nCSC\n in Finland, and \nCGAL\n, a\ncomputational geometry library primarily developed by\n\nGeometryFactory\n in France.\nWe thank the developers of both projects\nfor their feedback and input on Elmer and CGAL related questions. Other\ncomponents depend on \nGMSH\n, \nVTK\n and\n\nPythonOCC\n.\n\n\nNon-GSSF workflow options include\nDocker-defined workflows. These may partially overlap, for example, by using the\nGSSF CGAL meshing tools to provide a volumetric mesh before launching an in-Docker\nworkflow. This is the point you could perhaps substitute a Taverna workflow, for\nthose more familiar with it.\n\n\nGSSF itself consists of a series of semi-optional steps based on a GSSF-XML\nconfiguration file. This file is actually fairly similar to the GSSA-XML, but\nmore case-specific to the workflow. For instance, it will have mesher\nconfiguration indicating which surfaces the CGAL mesher should include. GSSA\ncontains a module for compiling GSSA-XML to GSSF-XML, if possible.\n\n\nIt is entirely reasonable to use GSSF separately from the rest of the GSSA\narchitecture, starting with a GSSF-XML settings file and appropriately laid out\ndirectory. This is especially useful for offline debugging of simulation\nsettings, which you may (or may not) want to update in the \nCDM\n later,\nbut, in general, provides a simple workflow for taking STL surfaces, producing a\nvolumetric mesh, running an Elmer simulation and returning a clean STL\nisosurface. Moreover, it is scriptable and using fairly flexible command-line\narguments, and terminal output is nicely colour-coded.\n\n\nExecution of the workflow is managed by \ngo-smart-launcher\n.\n\n\nWorkflow\n\n\nThe workflow follows the illustrated steps. It executes (in order), the \nNeedle\nLibrary\n, the \nmeshers\n, the \nmesh\noptimizer\n, \nElmerGrid\n, the \nsolver\n then\n\nlesion extraction\n on the results. It may also, if configured, run\n\nvalidation\n.\n\n\n\n\nDirectory layout\n\n\nOn start-up of \ngo-smart-launcher\n, GSSF is given a GSSF-XML file.\nConventionally, this is named \nsettings.xml\n and placed in the working directory\nwith all input STL files in a subfolder \ninput\n.\n\n\ninput/\nsettings.xml\n\n\n\nAs the workflow progresses, separate directories are created for each component\n(possibly multiple for certain components).\n\n\ninput/\nelmer/\nelmergrid/\n...\nlesion/\nlogger/\noutput/\nvalidation/\nsettings.xml\n\n\n\nThe final output STL surface should appear in the \noutput\n folder prior to\nsuccessful exit. The \nlogs\n for all components are, by default, kept in the\n\nlogger\n directory.\n\n\nImprovements\n\n\n\n\nThis should be run as part of a normal Docker workflow, rather than as a\n  special case\n\n\nThe use of \nlogger\n as a singleton should be minimized", 
            "title": "Overview"
        }, 
        {
            "location": "/gssf/overview/#go-smart-simulation-framework", 
            "text": "The simulation framework (as opposed to the architecture) is a single specific\nworkflow that allows a user to provide a set of STL surfaces and Elmer\nconfiguration, and get back a lesion surface.  This workflow is based primarily on  Elmer FEM ,\na Finite Element multiphysics package primarily developed by CSC  in Finland, and  CGAL , a\ncomputational geometry library primarily developed by GeometryFactory  in France.\nWe thank the developers of both projects\nfor their feedback and input on Elmer and CGAL related questions. Other\ncomponents depend on  GMSH ,  VTK  and PythonOCC .  Non-GSSF workflow options include\nDocker-defined workflows. These may partially overlap, for example, by using the\nGSSF CGAL meshing tools to provide a volumetric mesh before launching an in-Docker\nworkflow. This is the point you could perhaps substitute a Taverna workflow, for\nthose more familiar with it.  GSSF itself consists of a series of semi-optional steps based on a GSSF-XML\nconfiguration file. This file is actually fairly similar to the GSSA-XML, but\nmore case-specific to the workflow. For instance, it will have mesher\nconfiguration indicating which surfaces the CGAL mesher should include. GSSA\ncontains a module for compiling GSSA-XML to GSSF-XML, if possible.  It is entirely reasonable to use GSSF separately from the rest of the GSSA\narchitecture, starting with a GSSF-XML settings file and appropriately laid out\ndirectory. This is especially useful for offline debugging of simulation\nsettings, which you may (or may not) want to update in the  CDM  later,\nbut, in general, provides a simple workflow for taking STL surfaces, producing a\nvolumetric mesh, running an Elmer simulation and returning a clean STL\nisosurface. Moreover, it is scriptable and using fairly flexible command-line\narguments, and terminal output is nicely colour-coded.  Execution of the workflow is managed by  go-smart-launcher .", 
            "title": "Go-Smart Simulation Framework"
        }, 
        {
            "location": "/gssf/overview/#workflow", 
            "text": "The workflow follows the illustrated steps. It executes (in order), the  Needle\nLibrary , the  meshers , the  mesh\noptimizer ,  ElmerGrid , the  solver  then lesion extraction  on the results. It may also, if configured, run validation .", 
            "title": "Workflow"
        }, 
        {
            "location": "/gssf/overview/#directory-layout", 
            "text": "On start-up of  go-smart-launcher , GSSF is given a GSSF-XML file.\nConventionally, this is named  settings.xml  and placed in the working directory\nwith all input STL files in a subfolder  input .  input/\nsettings.xml  As the workflow progresses, separate directories are created for each component\n(possibly multiple for certain components).  input/\nelmer/\nelmergrid/\n...\nlesion/\nlogger/\noutput/\nvalidation/\nsettings.xml  The final output STL surface should appear in the  output  folder prior to\nsuccessful exit. The  logs  for all components are, by default, kept in the logger  directory.", 
            "title": "Directory layout"
        }, 
        {
            "location": "/gssf/overview/#improvements", 
            "text": "This should be run as part of a normal Docker workflow, rather than as a\n  special case  The use of  logger  as a singleton should be minimized", 
            "title": "Improvements"
        }, 
        {
            "location": "/gssf/go-smart-launcher/", 
            "text": "Go-Smart Simulation Framework - Launcher script (go-smart-launcher)\n\n\nCommand line usage\n\n\nWrapper for Go-Smart simulation environment. This is the usual entry point to\nGSSF and is invoked by the GSSA server with when used inside the architecture.\nIt may, however, be used standalone from the command-line.\n\n\ngo-smart-launcher [-h] [--elmer ELMER_BINARY]\n                  [--elmer-logfile OUTFILENAME] [--logfile-addpid]\n                  [--silent] [--debug] [--nprocs NPROCS] [--only ONLY]\n                  [--black-and-white] [--leavetree]\n                  [--cwd GLOBAL_WORKING_DIRECTORY]\n                  [--status-socket UPDATE_STATUS]\n                  configfilenames\n                  ...\n\n\n\n\nPositional arguments\n\n\n\n\n\n\n\n\nArgument\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nconfigfilenames\n\n\nLocations of configuration file (latter override former)\n\n\n\n\n\n\n\n\nOptional arguments\n\n\n\n\n\n\n\n\nArgument\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n-h, --help\n\n\nshow this help message and exit\n\n\n\n\n\n\n--elmer ELMER_BINARY\n\n\nname of the ElmerSolver binary\n\n\n\n\n\n\n--elmer-logfile OUTFILENAME\n\n\nname of the ElmerSolver binary\n\n\n\n\n\n\n--logfile-addpid\n\n\nwhether the PID should be appended to the given\n\n\n\n\n\n\n\n\nlogfile name\n\n\n\n\n\n\n--silent\n\n\nprevent wrapper output\n\n\n\n\n\n\n--debug\n\n\nadditional, debug output (overridden by --silent)\n\n\n\n\n\n\n--nprocs NPROCS\n\n\nnumber of processes to start\n\n\n\n\n\n\n--only ONLY\n\n\nonly execute a single component\n\n\n\n\n\n\n--black-and-white\n\n\nforce colorama off\n\n\n\n\n\n\n--leavetree\n\n\ndo not touch the mesh filetree in Elmer\n\n\n\n\n\n\n--cwd GLOBAL_WORKING_DIRECTORY\n\n\noverride working directory as root of simulation\n\n\n\n\n\n\n--status-socket UPDATE_STATUS\n\n\nlocation of socket to which to write status", 
            "title": "go-smart-launcher"
        }, 
        {
            "location": "/gssf/go-smart-launcher/#go-smart-simulation-framework-launcher-script-go-smart-launcher", 
            "text": "", 
            "title": "Go-Smart Simulation Framework - Launcher script (go-smart-launcher)"
        }, 
        {
            "location": "/gssf/go-smart-launcher/#command-line-usage", 
            "text": "Wrapper for Go-Smart simulation environment. This is the usual entry point to\nGSSF and is invoked by the GSSA server with when used inside the architecture.\nIt may, however, be used standalone from the command-line.  go-smart-launcher [-h] [--elmer ELMER_BINARY]\n                  [--elmer-logfile OUTFILENAME] [--logfile-addpid]\n                  [--silent] [--debug] [--nprocs NPROCS] [--only ONLY]\n                  [--black-and-white] [--leavetree]\n                  [--cwd GLOBAL_WORKING_DIRECTORY]\n                  [--status-socket UPDATE_STATUS]\n                  configfilenames\n                  ...  Positional arguments     Argument  Description      configfilenames  Locations of configuration file (latter override former)     Optional arguments     Argument  Description      -h, --help  show this help message and exit    --elmer ELMER_BINARY  name of the ElmerSolver binary    --elmer-logfile OUTFILENAME  name of the ElmerSolver binary    --logfile-addpid  whether the PID should be appended to the given     logfile name    --silent  prevent wrapper output    --debug  additional, debug output (overridden by --silent)    --nprocs NPROCS  number of processes to start    --only ONLY  only execute a single component    --black-and-white  force colorama off    --leavetree  do not touch the mesh filetree in Elmer    --cwd GLOBAL_WORKING_DIRECTORY  override working directory as root of simulation    --status-socket UPDATE_STATUS  location of socket to which to write status", 
            "title": "Command line usage"
        }, 
        {
            "location": "/gssf/xml/", 
            "text": "GSSF XML Configuration Format (GSSF-XML)\n\n\nGSSF-XML is the workflow-specific configuration for a simulation. Along with\nany STL input files, it is sufficient to run a simulation.\n\n\nNote that this\nis distinct from the (workflow-independent) GSSA-XML format\n. A processor, compiling\nGSSA-XML to GSSF-XML is included in GSSA. The workflow-specific nature of\nGSSF-XML gives it a distinctive character. A few sections are similar to the\nGSSA-XML definition, in that they define over-arching problem characteristics\n(such as geometry), but in GSSF-XML, each component of the workflow also has a\nseparate section with its own configuration.\n\n\nFormat\n\n\nThis describes the general format of a GSSF-XML file.\n\n\ngosmart [ debug=\"DEBUG:bool\" ] [ version=\"GSSF_XML_VERSION:0.1.0\" ] [ name=\"RUNNAME\" ]\n\n      \ngeometry\n\n        \ncentre x=\"CX\" y=\"CY\" z=\"CZ\" /\n\n        \nneedleaxis x=\"NX\" y=\"NY\" z=\"NZ\" /\n\n        \nsimulationscaling ratio=\"SCALING\" /\n\n      \n/geometry\n\n      \nregions\n\n        \nsurface|zone|both name=\"REGIONNAME\" input=\"INPUTLOCATION\" groups=\"GROUP1; GROUP2;...\" /\n\n        ...\n      \n/regions\n\n      \nconstants\n\n        \nconstant name=\"PARAMNAME\" value=\"PARAMVALUE\" type=\"PARAMTYPE\" /\n\n        ...\n      \n/constants\n\n    [ \nneedles\n\n        \nneedle name=\"NEEDLEID\"\n\n          [ \nparameters\n\n              \nparameter name=\"PARAMNAME\" value=\"PARAMVALUE\" type=\"PARAMTYPE\" /\n\n              ...\n            \n/parameters\n ]\n        \n/needle\n\n        ...\n      \n/needles\n ]\n    [ \nneedlelibrary\n\n        \n!-- see 'Needle Library Component' --\n\n      \n/needlelibrary\n ]\n    [ \nmesher\n\n        \n!-- see 'Meshing Components' --\n\n      \n/mesher\n ]\n    [ \noptimizer\n\n        \n!-- see 'Optimizer Component' --\n\n      \n/optimizer\n ]\n    [ \nelmergrid\n\n        \n!-- see 'ElmerGrid Component' --\n\n      \n/elmergrid\n ]\n    [ \nelmer\n\n        \n!-- see 'ElmerSolver Component' --\n\n      \n/elmer\n ]\n    [ \nlesion\n\n        \n!-- see 'Lesion Component' --\n\n      \n/lesion\n ]\n    [ \nvalidation\n\n        \n!-- see 'Validation Component' --\n\n      \n/validation\n ]\n\n/gosmart\n\n\n\n\nThe XML version is given by \nGSSF_XML_VERSION\n. The latest version, described\nhere, is \n0.1.0\n. Note European spelling of \ncentre\n.\n\n\nXML Schema\n\n\nThis is a \nTODO\n. For the moment, the documentation here should be adequate\nto perform basic creation and manipulation of GSSF-XML.\nHowever, in keeping with the increasing importance of\nDocker-workflow and the presence of an automatic GSSA-XML \n GSSF-XML\ngenerator, this is secondary to the GSSA-XML formalization.", 
            "title": "GSSF XML Format"
        }, 
        {
            "location": "/gssf/xml/#gssf-xml-configuration-format-gssf-xml", 
            "text": "GSSF-XML is the workflow-specific configuration for a simulation. Along with\nany STL input files, it is sufficient to run a simulation.  Note that this\nis distinct from the (workflow-independent) GSSA-XML format . A processor, compiling\nGSSA-XML to GSSF-XML is included in GSSA. The workflow-specific nature of\nGSSF-XML gives it a distinctive character. A few sections are similar to the\nGSSA-XML definition, in that they define over-arching problem characteristics\n(such as geometry), but in GSSF-XML, each component of the workflow also has a\nseparate section with its own configuration.", 
            "title": "GSSF XML Configuration Format (GSSF-XML)"
        }, 
        {
            "location": "/gssf/xml/#format", 
            "text": "This describes the general format of a GSSF-XML file.  gosmart [ debug=\"DEBUG:bool\" ] [ version=\"GSSF_XML_VERSION:0.1.0\" ] [ name=\"RUNNAME\" ] \n       geometry \n         centre x=\"CX\" y=\"CY\" z=\"CZ\" / \n         needleaxis x=\"NX\" y=\"NY\" z=\"NZ\" / \n         simulationscaling ratio=\"SCALING\" / \n       /geometry \n       regions \n         surface|zone|both name=\"REGIONNAME\" input=\"INPUTLOCATION\" groups=\"GROUP1; GROUP2;...\" / \n        ...\n       /regions \n       constants \n         constant name=\"PARAMNAME\" value=\"PARAMVALUE\" type=\"PARAMTYPE\" / \n        ...\n       /constants \n    [  needles \n         needle name=\"NEEDLEID\" \n          [  parameters \n               parameter name=\"PARAMNAME\" value=\"PARAMVALUE\" type=\"PARAMTYPE\" / \n              ...\n             /parameters  ]\n         /needle \n        ...\n       /needles  ]\n    [  needlelibrary \n         !-- see 'Needle Library Component' -- \n       /needlelibrary  ]\n    [  mesher \n         !-- see 'Meshing Components' -- \n       /mesher  ]\n    [  optimizer \n         !-- see 'Optimizer Component' -- \n       /optimizer  ]\n    [  elmergrid \n         !-- see 'ElmerGrid Component' -- \n       /elmergrid  ]\n    [  elmer \n         !-- see 'ElmerSolver Component' -- \n       /elmer  ]\n    [  lesion \n         !-- see 'Lesion Component' -- \n       /lesion  ]\n    [  validation \n         !-- see 'Validation Component' -- \n       /validation  ] /gosmart   The XML version is given by  GSSF_XML_VERSION . The latest version, described\nhere, is  0.1.0 . Note European spelling of  centre .", 
            "title": "Format"
        }, 
        {
            "location": "/gssf/xml/#xml-schema", 
            "text": "This is a  TODO . For the moment, the documentation here should be adequate\nto perform basic creation and manipulation of GSSF-XML.\nHowever, in keeping with the increasing importance of\nDocker-workflow and the presence of an automatic GSSA-XML   GSSF-XML\ngenerator, this is secondary to the GSSA-XML formalization.", 
            "title": "XML Schema"
        }, 
        {
            "location": "/gssf/family/", 
            "text": "Go-Smart Simulation Framework Family in GSSA\n\n\nGSSA \nfamilies\n prepare configuration for running a solver, in\nthis case GSSF. This is in the form of a Python class extending\n\ngssa.family.Family\n. There are actually two components comprising the GSSF\nFamily.\n\n\nElmer-libnuma\n\n\nThis refers to Elmer run in conjunction with some\n\nNUMA\n-written libraries, and more generally to GSSF, which\nis centred around this pairing.\n\n\nMesherGSSFMixin\n\n\nThis is a mixin, used in GSSF and elsewhere for setting up a volumetric mesh\nusing \nGSSF-XML\n. In the Elmer-libnuma case, it only prepares the\nrelevant part of the XML file, which is completed and run by the Elmer-libnuma\nfamily. In other cases, the volumetric entries only are used and run by\n\ngo-smart-launcher\n, before whichever component into which\nthis is mixed in takes the output MSH file for its own simulation.\n\n\nParameters used\n\n\n\n\n\n\n\n\nParameter name\n\n\nDescription (effect on output GSSF-XML)\n\n\n\n\n\n\n\n\n\n\nNEEDLE_TIP_LOCATION\n\n\nUsed to find the offset for each needle. If the \nCENTRE_LOCATION\n has not been provided, this is used to provide the \ngeometry\n centre\n\n\n\n\n\n\nNEEDLE_ENTRY_LOCATION\n\n\nWith each needle tip, this is used to find the needle axis and the first needle is used to provide the \ngeometry\n section's \nneedleaxis\n\n\n\n\n\n\nNEEDLE_ACTIVE_LENGTH\n\n\nSize of active length sphere for specific needle, as used in the \nactive\n section in the relevant \nmesher\n section \nneedle\n\n\n\n\n\n\nSETTING_SOLID_NEEDLES\n\n\nIndicates that all needle geometries should be meshed solidly, prompting the \nzones\n attribute of \nneedlelibrary\n and \nzone_boundaries\n of \nmesher\n to be set\n\n\n\n\n\n\nCONSTANT_GLOBAL_ACTIVE_LENGTH\n\n\nSize of default active length, to be used in the \nactive\n section in the relevant \nmesher\n section \nneedle\n\n\n\n\n\n\nCENTRE_LOCATION\n\n\nDefault \ngeometry\n centre in GSSF-XML. May be a JSON float triple or \nfirst-needle\n (to use tip of first needle) or \ncentroid-of-tips\n to calculate the combined centre of all needle tips\n\n\n\n\n\n\nCENTRE_OFFSET\n\n\nThis adds an offset to the \ngeometry\n centre, without altering the needle location\n\n\n\n\n\n\nSIMULATION_SCALING\n\n\nBecomes the \ngeometry\n section \nsimulationscaling\n\n\n\n\n\n\nSETTING_ORGAN_AS_SUBDOMAIN\n\n\nSwitches the \norgan\n from an \norgan\n in the \nmesher\n to a \nzone\n\n\n\n\n\n\nSETTING_AXISYMMETRIC_INNER\n\n\nAdds an \ninner\n to the \nmesher\n of the given template\n\n\n\n\n\n\nSETTING_AXISYMMETRIC_INNER_COARSE\n\n\nAdds a coarse \ninner\n to the \nmesher\n of the given template\n\n\n\n\n\n\nSIMULATION_DOMAIN_RADIUS\n\n\nGives a bounding radius for use in the \nmesher\n section \nextent\n\n\n\n\n\n\nRESOLUTION_HIGH\n\n\nTriggers an approximately double resolution set of characteristic length parameters compared to the default\n\n\n\n\n\n\nRESOLUTION_FIELD_NEAR\n, \nRESOLUTION_FIELD_FAR\n, \nRESOLUTION_FIELD_ZONE\n, \nRESOLUTION_FIELD_NEEDLE_ZONE\n\n\nOverride specific characteristic length field parameters in the \nmesher\n section", 
            "title": "Family in GSSA"
        }, 
        {
            "location": "/gssf/family/#go-smart-simulation-framework-family-in-gssa", 
            "text": "GSSA  families  prepare configuration for running a solver, in\nthis case GSSF. This is in the form of a Python class extending gssa.family.Family . There are actually two components comprising the GSSF\nFamily.", 
            "title": "Go-Smart Simulation Framework Family in GSSA"
        }, 
        {
            "location": "/gssf/family/#elmer-libnuma", 
            "text": "This refers to Elmer run in conjunction with some NUMA -written libraries, and more generally to GSSF, which\nis centred around this pairing.", 
            "title": "Elmer-libnuma"
        }, 
        {
            "location": "/gssf/family/#meshergssfmixin", 
            "text": "This is a mixin, used in GSSF and elsewhere for setting up a volumetric mesh\nusing  GSSF-XML . In the Elmer-libnuma case, it only prepares the\nrelevant part of the XML file, which is completed and run by the Elmer-libnuma\nfamily. In other cases, the volumetric entries only are used and run by go-smart-launcher , before whichever component into which\nthis is mixed in takes the output MSH file for its own simulation.  Parameters used     Parameter name  Description (effect on output GSSF-XML)      NEEDLE_TIP_LOCATION  Used to find the offset for each needle. If the  CENTRE_LOCATION  has not been provided, this is used to provide the  geometry  centre    NEEDLE_ENTRY_LOCATION  With each needle tip, this is used to find the needle axis and the first needle is used to provide the  geometry  section's  needleaxis    NEEDLE_ACTIVE_LENGTH  Size of active length sphere for specific needle, as used in the  active  section in the relevant  mesher  section  needle    SETTING_SOLID_NEEDLES  Indicates that all needle geometries should be meshed solidly, prompting the  zones  attribute of  needlelibrary  and  zone_boundaries  of  mesher  to be set    CONSTANT_GLOBAL_ACTIVE_LENGTH  Size of default active length, to be used in the  active  section in the relevant  mesher  section  needle    CENTRE_LOCATION  Default  geometry  centre in GSSF-XML. May be a JSON float triple or  first-needle  (to use tip of first needle) or  centroid-of-tips  to calculate the combined centre of all needle tips    CENTRE_OFFSET  This adds an offset to the  geometry  centre, without altering the needle location    SIMULATION_SCALING  Becomes the  geometry  section  simulationscaling    SETTING_ORGAN_AS_SUBDOMAIN  Switches the  organ  from an  organ  in the  mesher  to a  zone    SETTING_AXISYMMETRIC_INNER  Adds an  inner  to the  mesher  of the given template    SETTING_AXISYMMETRIC_INNER_COARSE  Adds a coarse  inner  to the  mesher  of the given template    SIMULATION_DOMAIN_RADIUS  Gives a bounding radius for use in the  mesher  section  extent    RESOLUTION_HIGH  Triggers an approximately double resolution set of characteristic length parameters compared to the default    RESOLUTION_FIELD_NEAR ,  RESOLUTION_FIELD_FAR ,  RESOLUTION_FIELD_ZONE ,  RESOLUTION_FIELD_NEEDLE_ZONE  Override specific characteristic length field parameters in the  mesher  section", 
            "title": "MesherGSSFMixin"
        }, 
        {
            "location": "/gssf/logging/", 
            "text": "Logging \n Errors in GSSF\n\n\nLogging tools\n\n\nStatistics monitoring\n\n\nGSSF has prototypal integration with\n\nvigilant\n, a tool that maintains a\ndatastore monitoring all instances of (in our case)\n\ngo-smart-launcher\n. It can do so across\nmultiple machines and provides a web-based interface for viewing. Note that this\nis entirely distinct from GSSA, which orchestrates workflows such as GSSF, and\nis unaware of vigilant monitoring.\n\n\nNote that \nvigilant\n has changed name during the Go-Smart project, from\n\nobservant\n. This name is often used in the code and will be replaced as the\ndependencies are updated. However, as the project is currently \nvigilant\n, and\nseems to be going forward, the comments generally use this name to refer to it.\n\n\nMonitoring can be configured using the YAML file\n\n{INSTALLROOT}/etc/gosmart/vigilant.cfg\n. Configuration options are as described\nin the \nvigilant\n documentation.\n\n\nTODO\n: Update configuration format to JSON, following upstream change.\n\n\nFIXME\n: Posting vigilant messages on \nlog_line\n is currently suspended,\nas the filling pipe was slowing the rest of the master process. While this needs to be\nfarmed out to a thread properly, for the moment test this functionality by\nuncommenting the marked line in logger_vigilant.py.\n\n\nLogpick\n\n\nThe logpick functionality allows individual components of the GSSF workflow to\nmonitor their child process output for certain regular expressions, indicating\nthe start and end of some internal process. The GoSmartComponent class, on which\nall the components are based, will sum the time spent in this internal task\n(based on the child's output) and print the total when the subprocess exits. The\nlogpick entries are expressed as a triple in \nGoSmartComponent.logpick_pairs\n:\n\n\n(\"START_PATTERN\", \"END_PATTERN\", \"LABEL\")\n\n\n\nFor example, in the Elmer solver:\n\n\n(\"CRS_IncompleteLU: ILU(0) (Real), Starting Factorization\", \"ComputeChange:\", \"Solver A\")\n\n\n\ngives, when the solver finally exits,\n\n\nTimings (sec resolution):\n --    9 Solver A \n'CRS_IncompleteLU: ILU(0) (Real), Starting Factorization' - 'ComputeChange:'\n\n --  486 [other]\n    ====   \n -- 496\n\n\n\nAdding additional logpick entries will, naturally, help account for more of the\ntime used.\n\n\nRate limiting\n\n\nEach component has a member \nsuppress_logging_over_per_second\n, which may be\nset to a maximum number of log lines per second from that component or \nNone\n\nto be disabled.\n\n\nError handling\n\n\nException classes\n\n\nIdeally, in GSSF all errors thrown should be one of the classes listed on the\n\nErrors\n page, found in \ngssf.errors\n. These will be caught by\n\ngo-smart-launcher\n and an error file written that GSSA\ncan process and report accordingly. If using GSSF standalone, this will still\nwork properly.\n\n\nError regexes\n\n\nEach line is checked for a per-component error regex, and stored as the\nsubprocess error message if it occurs. Since the subprocess may know nothing\nabout GSSF, such an approach is required to ensure we can provide some feedback,\nat least, if it crashes.", 
            "title": "Logging &amp; Errors"
        }, 
        {
            "location": "/gssf/logging/#logging-errors-in-gssf", 
            "text": "", 
            "title": "Logging &amp; Errors in GSSF"
        }, 
        {
            "location": "/gssf/logging/#logging-tools", 
            "text": "Statistics monitoring  GSSF has prototypal integration with vigilant , a tool that maintains a\ndatastore monitoring all instances of (in our case) go-smart-launcher . It can do so across\nmultiple machines and provides a web-based interface for viewing. Note that this\nis entirely distinct from GSSA, which orchestrates workflows such as GSSF, and\nis unaware of vigilant monitoring.  Note that  vigilant  has changed name during the Go-Smart project, from observant . This name is often used in the code and will be replaced as the\ndependencies are updated. However, as the project is currently  vigilant , and\nseems to be going forward, the comments generally use this name to refer to it.  Monitoring can be configured using the YAML file {INSTALLROOT}/etc/gosmart/vigilant.cfg . Configuration options are as described\nin the  vigilant  documentation.  TODO : Update configuration format to JSON, following upstream change.  FIXME : Posting vigilant messages on  log_line  is currently suspended,\nas the filling pipe was slowing the rest of the master process. While this needs to be\nfarmed out to a thread properly, for the moment test this functionality by\nuncommenting the marked line in logger_vigilant.py.  Logpick  The logpick functionality allows individual components of the GSSF workflow to\nmonitor their child process output for certain regular expressions, indicating\nthe start and end of some internal process. The GoSmartComponent class, on which\nall the components are based, will sum the time spent in this internal task\n(based on the child's output) and print the total when the subprocess exits. The\nlogpick entries are expressed as a triple in  GoSmartComponent.logpick_pairs :  (\"START_PATTERN\", \"END_PATTERN\", \"LABEL\")  For example, in the Elmer solver:  (\"CRS_IncompleteLU: ILU(0) (Real), Starting Factorization\", \"ComputeChange:\", \"Solver A\")  gives, when the solver finally exits,  Timings (sec resolution):\n --    9 Solver A  'CRS_IncompleteLU: ILU(0) (Real), Starting Factorization' - 'ComputeChange:' \n --  486 [other]\n    ====   \n -- 496  Adding additional logpick entries will, naturally, help account for more of the\ntime used.  Rate limiting  Each component has a member  suppress_logging_over_per_second , which may be\nset to a maximum number of log lines per second from that component or  None \nto be disabled.", 
            "title": "Logging tools"
        }, 
        {
            "location": "/gssf/logging/#error-handling", 
            "text": "Exception classes  Ideally, in GSSF all errors thrown should be one of the classes listed on the Errors  page, found in  gssf.errors . These will be caught by go-smart-launcher  and an error file written that GSSA\ncan process and report accordingly. If using GSSF standalone, this will still\nwork properly.  Error regexes  Each line is checked for a per-component error regex, and stored as the\nsubprocess error message if it occurs. Since the subprocess may know nothing\nabout GSSF, such an approach is required to ensure we can provide some feedback,\nat least, if it crashes.", 
            "title": "Error handling"
        }, 
        {
            "location": "/gssf/constants/", 
            "text": "Constants in GSSF\n\n\nIn GSSF code, parameters are generally referred to as \nconstants\n, which is not\nentirely accurate (TODO), but reflects the fact that the definition itself does\nnot usually change throughout the simulation. They are generally\nfloats/ints/etc. but may be MATC functions that are dropped into the SIF at the\nstart of the simulation.\n\n\nConstants in GSSF mostly arise from the parameters set in the GSSF-XML, but\ninclude other values such as the mesh scaling, which is not (in GSSF) in the\nparameter section. They are also used to transfer certain values between\ncomponents, where one calculates and adds a constant to the global space and\nanother uses it.\n\n\nParameters in the Elmer SIF template\n\n\nThe \nSIF template\n is a\n\nJinja2\n template. As such, Python parameter\ndictionaries are used to pass parameters into the template. These are named \np\n\nand \nneedles\n, being the global and needle-specific parameters, respectively. The\nneedle parameter dictionary, \nneedles\n, is a dictionary of parameter dictionaries,\nindexed as integers based on the needle indexes from the GSSF-XML.\n\n\nThe parameter dictionaries are of class \nParameterDict\n, which extends Python's\n\ndict\n built-in. In particular, these can be used with the member syntax:\n\np.CONSTANT_BODY_TEMPERATURE\n, for example, will return the relevant \nParameter\n\nobject for that parameter. This actually covers all global constants, not just\nthe GSSF parameters, so a few extra items are available. For instance,\n\np.NEEDLE_AXIS_SCALE_X\n will return the scaling in the \nx\n direction used by the\nneedle library.\n\n\nThe \nParameter\n class, to which the returned parameters belong, is castable to\nfloat, int and string. The Jinja filter \ntyped\n will cause it to be output with\nits SIF type as a prefix (useful, for example, when assigning to a property in\nthe SIF file). If not otherwise cast, it will appear as a string representation.\nIf the parameter type is an array, it will be converted to a space separated\nlist.\n\n\nFor instance, if the following line appears in the SIF template:\n\n\n...\nPower = {{ p.CONSTANT_INPUT_POWER|typed }}\n...\n\n\n\nand the parameter in the GSSF-XML is:\n\n\nconstant name=\"CONSTANT_INPUT_POWER\" value=\"140.0\" type=\"float\" /\n\n\n\n\nthe rendered SIF will be:\n\n\n...\nPower = Real 140.0\n...\n\n\n\nwhereas, if the parameter in the GSSF-XML is:\n\n\nconstant name=\"CONSTANT_INPUT_POWER\" value=\"[140.0, 200.0, 120.0]\" type=\"array(float)\" /\n\n\n\n\nthe rendered SIF will be:\n\n\n...\nPower = Real 140.0 200.0 120.0\n...\n\n\n\nNote that this does not take care of the need to supply an index count to the\npower list. A conditional may be needed.", 
            "title": "Constants"
        }, 
        {
            "location": "/gssf/constants/#constants-in-gssf", 
            "text": "In GSSF code, parameters are generally referred to as  constants , which is not\nentirely accurate (TODO), but reflects the fact that the definition itself does\nnot usually change throughout the simulation. They are generally\nfloats/ints/etc. but may be MATC functions that are dropped into the SIF at the\nstart of the simulation.  Constants in GSSF mostly arise from the parameters set in the GSSF-XML, but\ninclude other values such as the mesh scaling, which is not (in GSSF) in the\nparameter section. They are also used to transfer certain values between\ncomponents, where one calculates and adds a constant to the global space and\nanother uses it.", 
            "title": "Constants in GSSF"
        }, 
        {
            "location": "/gssf/constants/#parameters-in-the-elmer-sif-template", 
            "text": "The  SIF template  is a Jinja2  template. As such, Python parameter\ndictionaries are used to pass parameters into the template. These are named  p \nand  needles , being the global and needle-specific parameters, respectively. The\nneedle parameter dictionary,  needles , is a dictionary of parameter dictionaries,\nindexed as integers based on the needle indexes from the GSSF-XML.  The parameter dictionaries are of class  ParameterDict , which extends Python's dict  built-in. In particular, these can be used with the member syntax: p.CONSTANT_BODY_TEMPERATURE , for example, will return the relevant  Parameter \nobject for that parameter. This actually covers all global constants, not just\nthe GSSF parameters, so a few extra items are available. For instance, p.NEEDLE_AXIS_SCALE_X  will return the scaling in the  x  direction used by the\nneedle library.  The  Parameter  class, to which the returned parameters belong, is castable to\nfloat, int and string. The Jinja filter  typed  will cause it to be output with\nits SIF type as a prefix (useful, for example, when assigning to a property in\nthe SIF file). If not otherwise cast, it will appear as a string representation.\nIf the parameter type is an array, it will be converted to a space separated\nlist.  For instance, if the following line appears in the SIF template:  ...\nPower = {{ p.CONSTANT_INPUT_POWER|typed }}\n...  and the parameter in the GSSF-XML is:  constant name=\"CONSTANT_INPUT_POWER\" value=\"140.0\" type=\"float\" /   the rendered SIF will be:  ...\nPower = Real 140.0\n...  whereas, if the parameter in the GSSF-XML is:  constant name=\"CONSTANT_INPUT_POWER\" value=\"[140.0, 200.0, 120.0]\" type=\"array(float)\" /   the rendered SIF will be:  ...\nPower = Real 140.0 200.0 120.0\n...  Note that this does not take care of the need to supply an index count to the\npower list. A conditional may be needed.", 
            "title": "Parameters in the Elmer SIF template"
        }, 
        {
            "location": "/gssf/regions/", 
            "text": "Regions and Geometry in GSSF\n\n\nGeometry\n\n\nA specific simulation workflow has certain overarching geometrical information.\nThese are provided in the \ngeometry\n section of the \nGSSF-XML\n file.\nIn particular, there are:\n\n\n\n\n\n\n\n\nProperty (Type)\n\n\nEntry in \ngeometry\n dictionary\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nCentre \n(x, y, z)\n\n\ncentre\n\n\nFocal point of the simulation. Often a needle tip. Other locations generally expressed as an offset from this location. Default centre of simulation extent\n\n\n\n\n\n\nNeedle axis \n(x, y, z)\n\n\nneedleaxis\n\n\nPrimary/default axis for the simulation. May or may not be an actual axis of a needle, but will be used as a fallback if a needle axis is not provided.\n\n\n\n\n\n\nSimulation scaling factor \n(r)\n\n\nsimulationscaling\n\n\nThe (multiplicative) ratio going from input surface length scales (e.g. mm) to simulation length scales (e.g. m)\n\n\n\n\n\n\n\n\nThese may be referred to, and assumed to exist, in any component.\n\n\nRegions\n\n\nRegions are geometric entities. They may be either 2D subdomains (boundary\nsubdomains) or 3D subdomains. They are specified in the \nGSSF-XML\n by\none of the three tags:\n\n\n    \nsurface name=\nREGIONNAME\n input=\nINPUTLOCATION\n groups=\nGROUP1; GROUP2;...\n /\n\n    \nzone name=\nREGIONNAME\n input=\nINPUTLOCATION\n groups=\nGROUP1; GROUP2;...\n /\n\n    \nboth name=\nREGIONNAME\n input=\nINPUTLOCATION\n groups=\nGROUP1; GROUP2;...\n /\n\n\n\n\n\nThe \nREGIONNAME\n may be any string used to refer to the region elsewhere in the\nconfiguration (such as the \nmesher\n) and the \nINPUTLOCATION\n is\nusually the filename of the STL surface defining the region. This may be given\nrelative to the working directory. Generally, STL files are kept in an \ninput/\n\nsubdirectory.\n\n\nThe \nNeedle Library\n may add regions representing needles, as\n\nNEEDLE_[NEEDLEID]\n (and \nNEEDLE_[NEEDLEID]_ACTIVE\n,\n\nNEEDLE_[NEEDLEID]_INACTIVE\n if appropriate).\n\n\nLabelling\n\n\nRegions will be labelled by integers in the final mesh, which are used in the\nElmer SIF file to assign properties, boundary conditions and so forth. The\nrelationship between labels and regions is hard to predict if possible at all,\nas it is dependent on the volumetric meshing, number of subdomains appearing in\nthe simulation domain and ordering of assignment.\n\n\nAs such, the \nparameter dictionary\n accessible in the SIF template\ncontains region entries. For example:\n\n\nregions\n\n  \nsurface name=\"organ\" input... /\n\n  ...\n\n\n\nis used in the SIF template as follows:\n\n\n!===================\nBoundary Condition 3\n!===================\nTarget Boundary = Integer {{ p.REGION_ORGAN }}\nTemperature = {{ p.CONSTANT_BODY_TEMPERATURE|typed }}\n...\n\n\n\nThe conversion from region name to corresponding constant name uses\n\nslugify\n.\n\n\nGroups\n\n\nAs several regions can all effectively represent the same subdomain, or related\nsubdomains, \ngroups\n allow you to indicate this in GSSF-XML. This is by far the\nmore common way to include mesh indexes in the SIF template, as it future proofs\nagainst multiple related region entries, even if you currently only use one.\n\n\nGroups are notated, for example:\n\n\nsurface name=\"organ\" input=\"input/organ.stl\" groups=\"organs; outer-surfaces\" /\n\n\n\n\nIn this case, entries \nBOUNDARIES_ORGANS\n and \nBOUNDARIES_OUTER_SURFACES\n will\nbe created in the global parameter dictionary. These actually include the whole\ntarget boundary line in the SIF file, so if they are not present, the line is\nomitted and no syntax error occurs.\n\n\n!===================\nBoundary Condition 3\n!===================\n{{ p.BOUNDARIES_ORGANS }}\nTemperature = {{ p.CONSTANT_BODY_TEMPERATURE|typed }}\n...\n\n\n\nSimilarly, this is true for the needles in their parameter dictionaries, with\n\nneedles[id].BOUNDARIES_NEEDLE_ACTIVE\n and \nneedles[id].BOUNDARIES_NEEDLE_INACTIVE\n.", 
            "title": "Regions &amp; Geometry"
        }, 
        {
            "location": "/gssf/regions/#regions-and-geometry-in-gssf", 
            "text": "", 
            "title": "Regions and Geometry in GSSF"
        }, 
        {
            "location": "/gssf/regions/#geometry", 
            "text": "A specific simulation workflow has certain overarching geometrical information.\nThese are provided in the  geometry  section of the  GSSF-XML  file.\nIn particular, there are:     Property (Type)  Entry in  geometry  dictionary  Description      Centre  (x, y, z)  centre  Focal point of the simulation. Often a needle tip. Other locations generally expressed as an offset from this location. Default centre of simulation extent    Needle axis  (x, y, z)  needleaxis  Primary/default axis for the simulation. May or may not be an actual axis of a needle, but will be used as a fallback if a needle axis is not provided.    Simulation scaling factor  (r)  simulationscaling  The (multiplicative) ratio going from input surface length scales (e.g. mm) to simulation length scales (e.g. m)     These may be referred to, and assumed to exist, in any component.", 
            "title": "Geometry"
        }, 
        {
            "location": "/gssf/regions/#regions", 
            "text": "Regions are geometric entities. They may be either 2D subdomains (boundary\nsubdomains) or 3D subdomains. They are specified in the  GSSF-XML  by\none of the three tags:       surface name= REGIONNAME  input= INPUTLOCATION  groups= GROUP1; GROUP2;...  / \n     zone name= REGIONNAME  input= INPUTLOCATION  groups= GROUP1; GROUP2;...  / \n     both name= REGIONNAME  input= INPUTLOCATION  groups= GROUP1; GROUP2;...  /   The  REGIONNAME  may be any string used to refer to the region elsewhere in the\nconfiguration (such as the  mesher ) and the  INPUTLOCATION  is\nusually the filename of the STL surface defining the region. This may be given\nrelative to the working directory. Generally, STL files are kept in an  input/ \nsubdirectory.  The  Needle Library  may add regions representing needles, as NEEDLE_[NEEDLEID]  (and  NEEDLE_[NEEDLEID]_ACTIVE , NEEDLE_[NEEDLEID]_INACTIVE  if appropriate).  Labelling  Regions will be labelled by integers in the final mesh, which are used in the\nElmer SIF file to assign properties, boundary conditions and so forth. The\nrelationship between labels and regions is hard to predict if possible at all,\nas it is dependent on the volumetric meshing, number of subdomains appearing in\nthe simulation domain and ordering of assignment.  As such, the  parameter dictionary  accessible in the SIF template\ncontains region entries. For example:  regions \n   surface name=\"organ\" input... / \n  ...  is used in the SIF template as follows:  !===================\nBoundary Condition 3\n!===================\nTarget Boundary = Integer {{ p.REGION_ORGAN }}\nTemperature = {{ p.CONSTANT_BODY_TEMPERATURE|typed }}\n...  The conversion from region name to corresponding constant name uses slugify .  Groups  As several regions can all effectively represent the same subdomain, or related\nsubdomains,  groups  allow you to indicate this in GSSF-XML. This is by far the\nmore common way to include mesh indexes in the SIF template, as it future proofs\nagainst multiple related region entries, even if you currently only use one.  Groups are notated, for example:  surface name=\"organ\" input=\"input/organ.stl\" groups=\"organs; outer-surfaces\" /   In this case, entries  BOUNDARIES_ORGANS  and  BOUNDARIES_OUTER_SURFACES  will\nbe created in the global parameter dictionary. These actually include the whole\ntarget boundary line in the SIF file, so if they are not present, the line is\nomitted and no syntax error occurs.  !===================\nBoundary Condition 3\n!===================\n{{ p.BOUNDARIES_ORGANS }}\nTemperature = {{ p.CONSTANT_BODY_TEMPERATURE|typed }}\n...  Similarly, this is true for the needles in their parameter dictionaries, with needles[id].BOUNDARIES_NEEDLE_ACTIVE  and  needles[id].BOUNDARIES_NEEDLE_INACTIVE .", 
            "title": "Regions"
        }, 
        {
            "location": "/gssf/needle-library/", 
            "text": "Go-Smart Needle Library - STEP manipulation and geometry generation\n\n\nThis tool uses \nPythonOCC\n to generate triangulated\nsurfaces from STEP files, for representing needles and other features. It uses\nPythonOCC also for geometric transformation, allowing a single reference STEP to\nbe placed into a mesh in any location or of any scaling.\n\n\nWith the appropriate GSSA-XML extensions, this will allow a user to provide\ntheir own STEP geometry as the definition of a surface or surfaces in the mesh.\nThe present implementation provides some support for splitting an STEP file,\nwith the first listed component being output as an 'active' part, the second as\nan 'inactive' part, both in STL format.\n\n\ngo-smart-needle-library\n\n\nManagement tool for Go-Smart ablation needle geometry library\n\n\ngo-smart-needle-library [-h] [--logfile LOGFILENAME] [--logfile-addpid]\n                           [--silent] [--debug] [--output OUTFILE]\n                           [--output-extent EXTENTFILE]\n                           ...\n\n\n\nPositional arguments\n\n\n\n\n\n\n\n\nArgument\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nconfigfilenames\n\n\nLocations of configuration file (latter override former)\n\n\n\n\n\n\n\n\nOptional arguments\n\n\n\n\n\n\n\n\nArgument\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n-h, --help\n\n\nshow this help message and exit\n\n\n\n\n\n\n--logfile LOGFILENAME\n\n\nname of the log file\n\n\n\n\n\n\n--logfile-addpid\n\n\nwhether the PID should be appended to the given\n\n\n\n\n\n\n\n\nlogfile name\n\n\n\n\n\n\n--silent\n\n\nprevent wrapper output\n\n\n\n\n\n\n--debug\n\n\nadditional, debug output (overridden by --silent)\n\n\n\n\n\n\n--output OUTFILE\n\n\ndestination STL file for needle\n\n\n\n\n\n\n--output-extent EXTENTFILE\n\n\ndestination STL file for extent\n\n\n\n\n\n\n\n\nNeedle CAD geometries\n\n\nThese should lie along the z-axis, with tip at the origin and be in STEP format.\nOne or two roots (shapes) may exist. If two, the STEP will be split into two STL\nsurfaces, with the first marked as the 'active' surface, the second as the\n'inactive'. Interpretation is left to the modelling components of the workflow.\nIf multiple shapes are provided, they should be output in STLs suffixed by the\nordinal position in the STEP (1 \n n). This should work for n \n 2 but has\nnot been fully tested.\n\n\nGSSF component\n\n\nThe corresponding GSSF component forms a fairly transparent wrapper for\n\ngo-smart-needle-library\n.\n\n\nConfiguration\n\n\nThe second-level \nGSSF-XML\n tag is as follows:\n\n\n    \nneedlelibrary [ skip=\nBOOL:false\n ]\n\n        \nneedle id=\nID\n [ name=\nNAME\n ] [ axis=\nAX AY AZ\n ] [ offset=\nOX OY OZ\n ]/\n\n      [ \ntarget x=\nTX\n y=\nTY\n z=\nTZ\n /\n ]\n      [ \nextent x=\nTX\n y=\nTY\n z=\nTZ\n /\n ]\n    \n/needlelibrary\n\n\n\n\n\nThe \nid\n is the library name of the required template. It is recommended to\nwrite this as \nid=\"stock:ID\"\n for future compatibility. The name is a human\nreadable name to use to refer to this needle elsewhere in the simulation. If not\nprovided, the ordinal index of the \nneedle\n node will be used. The \naxis\n\noverrides the global \naxis\n from the \ngeometry\n section of [GSSF-XML][xml.md]\nfor this needle. The \noffset\n indicates the offset of this needle from the\ntarget of the needle-set, by default the geometry centre.\n\n\nThe \ntarget\n allows the user to specify an offset of the needle-set from the\ncentre of simulation as defined in the \ngeometry\n section.\nThe \nextent\n, if provided, instructs the \nneedlelibrary\n to generate an STL\nsimulation boundary. This may be intersected later with the organ boundary to\ngenerate an outer boundary of the simulation domain.", 
            "title": "Needle Library Component"
        }, 
        {
            "location": "/gssf/needle-library/#go-smart-needle-library-step-manipulation-and-geometry-generation", 
            "text": "This tool uses  PythonOCC  to generate triangulated\nsurfaces from STEP files, for representing needles and other features. It uses\nPythonOCC also for geometric transformation, allowing a single reference STEP to\nbe placed into a mesh in any location or of any scaling.  With the appropriate GSSA-XML extensions, this will allow a user to provide\ntheir own STEP geometry as the definition of a surface or surfaces in the mesh.\nThe present implementation provides some support for splitting an STEP file,\nwith the first listed component being output as an 'active' part, the second as\nan 'inactive' part, both in STL format.", 
            "title": "Go-Smart Needle Library - STEP manipulation and geometry generation"
        }, 
        {
            "location": "/gssf/needle-library/#go-smart-needle-library", 
            "text": "Management tool for Go-Smart ablation needle geometry library  go-smart-needle-library [-h] [--logfile LOGFILENAME] [--logfile-addpid]\n                           [--silent] [--debug] [--output OUTFILE]\n                           [--output-extent EXTENTFILE]\n                           ...  Positional arguments     Argument  Description      configfilenames  Locations of configuration file (latter override former)     Optional arguments     Argument  Description      -h, --help  show this help message and exit    --logfile LOGFILENAME  name of the log file    --logfile-addpid  whether the PID should be appended to the given     logfile name    --silent  prevent wrapper output    --debug  additional, debug output (overridden by --silent)    --output OUTFILE  destination STL file for needle    --output-extent EXTENTFILE  destination STL file for extent", 
            "title": "go-smart-needle-library"
        }, 
        {
            "location": "/gssf/needle-library/#needle-cad-geometries", 
            "text": "These should lie along the z-axis, with tip at the origin and be in STEP format.\nOne or two roots (shapes) may exist. If two, the STEP will be split into two STL\nsurfaces, with the first marked as the 'active' surface, the second as the\n'inactive'. Interpretation is left to the modelling components of the workflow.\nIf multiple shapes are provided, they should be output in STLs suffixed by the\nordinal position in the STEP (1   n). This should work for n   2 but has\nnot been fully tested.", 
            "title": "Needle CAD geometries"
        }, 
        {
            "location": "/gssf/needle-library/#gssf-component", 
            "text": "The corresponding GSSF component forms a fairly transparent wrapper for go-smart-needle-library .  Configuration  The second-level  GSSF-XML  tag is as follows:       needlelibrary [ skip= BOOL:false  ] \n         needle id= ID  [ name= NAME  ] [ axis= AX AY AZ  ] [ offset= OX OY OZ  ]/ \n      [  target x= TX  y= TY  z= TZ  /  ]\n      [  extent x= TX  y= TY  z= TZ  /  ]\n     /needlelibrary   The  id  is the library name of the required template. It is recommended to\nwrite this as  id=\"stock:ID\"  for future compatibility. The name is a human\nreadable name to use to refer to this needle elsewhere in the simulation. If not\nprovided, the ordinal index of the  needle  node will be used. The  axis \noverrides the global  axis  from the  geometry  section of [GSSF-XML][xml.md]\nfor this needle. The  offset  indicates the offset of this needle from the\ntarget of the needle-set, by default the geometry centre.  The  target  allows the user to specify an offset of the needle-set from the\ncentre of simulation as defined in the  geometry  section.\nThe  extent , if provided, instructs the  needlelibrary  to generate an STL\nsimulation boundary. This may be intersected later with the organ boundary to\ngenerate an outer boundary of the simulation domain.", 
            "title": "GSSF component"
        }, 
        {
            "location": "/gssf/mesher/", 
            "text": "Meshing Components in GSSF\n\n\nThese wrap the two primary meshing tools in GSSF: \nmesher-cgal\n and\n\nGMSH\n. This gives rise to two (current) subclasses of\n\nGoSmartMesher\n, each providing a component class: \n3D-CGAL\n and\n\n2D-GMSH\n. The specific type of component is specified using\nthe \ntype\n parameter in the XML.\n\n\nWhile most applications will use a single volumetric mesh, in certain cases it\nmay be necessary to use more than one mesh. Both (or more) will then be\navailable to the SIF template. Particular applications are: a highly detailed\nvolumetric mesh geometrically embedded in a simplified outer mesh; an\naxisymmetric mesh representing a portion of a larger Cartesian problem.\n\n\nAt least at present, meshing components are expected to output an MSH file. This\nmakes linkage more straightforward to the \nElmerGrid\n component.\n\n\nConfiguration\n\n\nThe relevant second-level element in GSSF-XML is:\n\n\n    \nmesher [ skip=\nSKIP:false\n ] type=\n(CGAL|axisymmetric)\n\n        [ \ninner type=\n(CGAL|axisymmetric)\n name=\nINNERNAME\n template=\nTEMPLATE\n\n                 [ region=\nINNERREGION\n ] [ needle=\n(inner_only|outer_only|both):both\n ]\n\n              \n!-- see CGAL/axisymmetric-specific sections --\n\n          \n/inner\n ]\n          \n!-- see CGAL/axisymmetric-specific sections --\n\n    \n/mesher\n\n\n\n\n\nAs a workaround for incomplete re-use of existing 2D meshes, \nSKIP\n may be\n\nouter\n instead of a boolean, to re-use an existing primary 3D mesh, but\nregenerate any inner (usu. 2D) meshes. In the case that there are no inner\nmeshes (most cases), this is equivalent to \ntrue\n.\n\n\nThe \ninner\n parameter \ntemplate\n, allows you to specify the template used for\nthe inner mesh - this is normally an axisymmetric needle geometry from the GSSF\nlibrary. The \nneedle\n attribute allows you to indicate in which mesh the needle\nshould be embedded, (although axisymmetric templates may not always adjust for\nthis parameter). The \nINNERREGION\n allows you to specify a \nregion\n\nthat should form an outer boundary for the inner mesh - this is currently implemented\nonly in the case of volumetric meshes, but strictly it could be extended to both.\n\n\nTODO\n: Allow user-supplied inner templates. Account for multiple needles when\nusing inner meshes.\n\n\n3D-CGAL\n\n\nThis is a component wrapping \nmesher-cgal\n.\n\n\nConfiguration\n\n\nThis is configured, extending the \nmesher\n or \ninner\n sections, as follows:\n\n\n   \nmesher|inner zone_boundaries=\nBOOL:false\n\n     \n!-- as in general configuration then --\n\n       \nlengthscales nearfield=\nNF\n farfield=\nFF\n [ zonefield=\nZF:(float|'ignore')\n ]\n                     [ needlezonefield=\nNZF\n ] [ granularity=\nGRANULARITY:float\n ]\n                     [ vessels=\n(near|far)\n ] [ needles=\nnear\n ] [ zones=\nsolid\n ]\n                     [ zone_radius=\nZONERADIUS:float\n ] /\n\n     ( \nextent radius=\nEXTENTRADIUS\n /\n | \nextent region=\nREGIONNAME\n /\n )\n     [ \ncentre x=\nCX\n y=\nCY\n z=\nCZ\n radius=\nCR\n /\n ]\n       \nzone|needle region=\nREGIONNAME\n [ characteristic_length=\nZCL\n ] [ priority=\nZP\n ]\n\n         [ \nactivity x=\nAX\n y=\nAY\n z=\nAZ\n r=\nAR\n /\n ]\n       \n/zone|needle\n\n       ...\n     [ \norgan region=\nREGIONNAME\n/\n ]\n       \nsurface region=\nREGIONNAME\n/\n\n       ...\n   \n/mesher|inner\n\n\n\n\n\nThe \nsurface\n is any boundary region (was previously \nvessel\n) and requires only\nthe name of the \nregion\n as expressed in the \nregions\n section. All\nglobal discretization information is contained in the lengthscales tag, which\nprovides parameters for the characteristic length field. The \nextent\n may be\nsupplied as a radius about the \ncentre\n or as a region. The \norgan\n, which is\nintersected with the \nextent\n, may be supplied separately as a region. Needles,\nif simply surfaces, only need a \nREGIONNAME\n but if a zone, or both, may use the\nextended zone attribute set.\n\n\nZones have, at least, a \nREGIONNAME\n but they may also have their own\ncharacteristic length field and priority, which indicates which zones obscure\nwhich in an overlap. Optionally, there may be a child \nactivity\n node,\nspecifying a sphere of activity. The inactive region will be added as a new\nregion to the global regions map.\n\n\n2D-GMSH\n\n\nGMSH\n is used to mesh 2D domains, primarily for use in\naxisymmetric problems.\n\n\nConfiguration\n\n\nThis is configured, extending the \nmesher\n or \ninner\n sections, as follows:\n\n\n   \nmesher|inner\n\n     \n!-- as in general configuration then --\n\n     \ntemplate name=\nTEMPLATENAME\n height=\nHEIGHT\n width=\nWIDTH\n\n        \ndimension name=\nDIMENSIONNAME\n value=\nDIMENSIONVALUE:float\n /\n\n     \n/template\n\n     \nlengthscales nearfield=\nNEARFIELD\n farfield=\nFARFIELD\n /\n\n   \n/mesher|inner\n\n\n\n\n\nThe \nTEMPLATENAME\n parameter indicates a library template to use (effectively a\nGMSH \n.geo\n template). The template may use \n$CONSTANT_XYZ\n to refer to\ndimension \nXYZ\n and \n$INNERHEIGHT\n or \n$INNERWIDTH\n to refer to \nHEIGHT\n or\n\nWIDTH\n, respectively. It may use \n$NEARFIELD\n and \n$FARFIELD\n to get the\n\nNEARFIELD\n and \nFARFIELD\n parameters, which should together be sufficient to\nset the characteristic lengths for GMSH. The template also has access to the\n\nregion\n IDs, which is prior to renumbering, but allows multiple\nmesher components to number consistently. These use the same constant naming\nscheme as the \nElmer\n SIF template (\nREGION_ORGAN\n, etc.). To parse\nthe template,\n\nstring.Template\n\nis used.\n\n\nTODO\n: Confirm this has no axisymmetric-specific behaviour and rename it to\nGMSH. Add support for supplied (non-library) templates.\n\n\nRenumbering\n\n\nFor Elmer to process a SIF file, numbering of bodies (volumetric subdomains)\nmust be contiguous. We use a application-level routine,\n\nGSSF.renumber_bodies(msh_files)\n, to achieve this,\nafter all other preliminary steps have been performed and we know exactly\nwhich subdomains appear in the simulation mesh. After this,\n\nElmerGrid\n is applied to convert to Elmer's meshing format. The output of\nthis step, not itself a full component, is in \nmeshes-reordered/\n. Other than\nnumbering, these meshes should match those output by the optimizer in \noptimizer/\n.\n\n\nTODO\n: to renumber in two steps, the mesh indices are temporarily replaced with\ncharacters using an ASCII mapping. This creates an artifical restriction to 26\nsubdomains, which could be avoided by a more elegant solution.", 
            "title": "Meshing Components"
        }, 
        {
            "location": "/gssf/mesher/#meshing-components-in-gssf", 
            "text": "These wrap the two primary meshing tools in GSSF:  mesher-cgal  and GMSH . This gives rise to two (current) subclasses of GoSmartMesher , each providing a component class:  3D-CGAL  and 2D-GMSH . The specific type of component is specified using\nthe  type  parameter in the XML.  While most applications will use a single volumetric mesh, in certain cases it\nmay be necessary to use more than one mesh. Both (or more) will then be\navailable to the SIF template. Particular applications are: a highly detailed\nvolumetric mesh geometrically embedded in a simplified outer mesh; an\naxisymmetric mesh representing a portion of a larger Cartesian problem.  At least at present, meshing components are expected to output an MSH file. This\nmakes linkage more straightforward to the  ElmerGrid  component.", 
            "title": "Meshing Components in GSSF"
        }, 
        {
            "location": "/gssf/mesher/#configuration", 
            "text": "The relevant second-level element in GSSF-XML is:       mesher [ skip= SKIP:false  ] type= (CGAL|axisymmetric) \n        [  inner type= (CGAL|axisymmetric)  name= INNERNAME  template= TEMPLATE \n                 [ region= INNERREGION  ] [ needle= (inner_only|outer_only|both):both  ] \n               !-- see CGAL/axisymmetric-specific sections -- \n           /inner  ]\n           !-- see CGAL/axisymmetric-specific sections -- \n     /mesher   As a workaround for incomplete re-use of existing 2D meshes,  SKIP  may be outer  instead of a boolean, to re-use an existing primary 3D mesh, but\nregenerate any inner (usu. 2D) meshes. In the case that there are no inner\nmeshes (most cases), this is equivalent to  true .  The  inner  parameter  template , allows you to specify the template used for\nthe inner mesh - this is normally an axisymmetric needle geometry from the GSSF\nlibrary. The  needle  attribute allows you to indicate in which mesh the needle\nshould be embedded, (although axisymmetric templates may not always adjust for\nthis parameter). The  INNERREGION  allows you to specify a  region \nthat should form an outer boundary for the inner mesh - this is currently implemented\nonly in the case of volumetric meshes, but strictly it could be extended to both.  TODO : Allow user-supplied inner templates. Account for multiple needles when\nusing inner meshes.", 
            "title": "Configuration"
        }, 
        {
            "location": "/gssf/mesher/#3d-cgal", 
            "text": "This is a component wrapping  mesher-cgal .  Configuration  This is configured, extending the  mesher  or  inner  sections, as follows:      mesher|inner zone_boundaries= BOOL:false \n      !-- as in general configuration then -- \n        lengthscales nearfield= NF  farfield= FF  [ zonefield= ZF:(float|'ignore')  ]\n                     [ needlezonefield= NZF  ] [ granularity= GRANULARITY:float  ]\n                     [ vessels= (near|far)  ] [ needles= near  ] [ zones= solid  ]\n                     [ zone_radius= ZONERADIUS:float  ] / \n     (  extent radius= EXTENTRADIUS  /  |  extent region= REGIONNAME  /  )\n     [  centre x= CX  y= CY  z= CZ  radius= CR  /  ]\n        zone|needle region= REGIONNAME  [ characteristic_length= ZCL  ] [ priority= ZP  ] \n         [  activity x= AX  y= AY  z= AZ  r= AR  /  ]\n        /zone|needle \n       ...\n     [  organ region= REGIONNAME /  ]\n        surface region= REGIONNAME / \n       ...\n    /mesher|inner   The  surface  is any boundary region (was previously  vessel ) and requires only\nthe name of the  region  as expressed in the  regions  section. All\nglobal discretization information is contained in the lengthscales tag, which\nprovides parameters for the characteristic length field. The  extent  may be\nsupplied as a radius about the  centre  or as a region. The  organ , which is\nintersected with the  extent , may be supplied separately as a region. Needles,\nif simply surfaces, only need a  REGIONNAME  but if a zone, or both, may use the\nextended zone attribute set.  Zones have, at least, a  REGIONNAME  but they may also have their own\ncharacteristic length field and priority, which indicates which zones obscure\nwhich in an overlap. Optionally, there may be a child  activity  node,\nspecifying a sphere of activity. The inactive region will be added as a new\nregion to the global regions map.", 
            "title": "3D-CGAL"
        }, 
        {
            "location": "/gssf/mesher/#2d-gmsh", 
            "text": "GMSH  is used to mesh 2D domains, primarily for use in\naxisymmetric problems.  Configuration  This is configured, extending the  mesher  or  inner  sections, as follows:      mesher|inner \n      !-- as in general configuration then -- \n      template name= TEMPLATENAME  height= HEIGHT  width= WIDTH \n         dimension name= DIMENSIONNAME  value= DIMENSIONVALUE:float  / \n      /template \n      lengthscales nearfield= NEARFIELD  farfield= FARFIELD  / \n    /mesher|inner   The  TEMPLATENAME  parameter indicates a library template to use (effectively a\nGMSH  .geo  template). The template may use  $CONSTANT_XYZ  to refer to\ndimension  XYZ  and  $INNERHEIGHT  or  $INNERWIDTH  to refer to  HEIGHT  or WIDTH , respectively. It may use  $NEARFIELD  and  $FARFIELD  to get the NEARFIELD  and  FARFIELD  parameters, which should together be sufficient to\nset the characteristic lengths for GMSH. The template also has access to the region  IDs, which is prior to renumbering, but allows multiple\nmesher components to number consistently. These use the same constant naming\nscheme as the  Elmer  SIF template ( REGION_ORGAN , etc.). To parse\nthe template, string.Template \nis used.  TODO : Confirm this has no axisymmetric-specific behaviour and rename it to\nGMSH. Add support for supplied (non-library) templates.", 
            "title": "2D-GMSH"
        }, 
        {
            "location": "/gssf/mesher/#renumbering", 
            "text": "For Elmer to process a SIF file, numbering of bodies (volumetric subdomains)\nmust be contiguous. We use a application-level routine, GSSF.renumber_bodies(msh_files) , to achieve this,\nafter all other preliminary steps have been performed and we know exactly\nwhich subdomains appear in the simulation mesh. After this, ElmerGrid  is applied to convert to Elmer's meshing format. The output of\nthis step, not itself a full component, is in  meshes-reordered/ . Other than\nnumbering, these meshes should match those output by the optimizer in  optimizer/ .  TODO : to renumber in two steps, the mesh indices are temporarily replaced with\ncharacters using an ASCII mapping. This creates an artifical restriction to 26\nsubdomains, which could be avoided by a more elegant solution.", 
            "title": "Renumbering"
        }, 
        {
            "location": "/gssf/optimizer/", 
            "text": "Optimizer GSSF Component\n\n\nThis is an extremely basic component, wrapping \nGMSH\n for mesh optimization.\n\n\nConfiguration\n\n\nThe second-level \nGSSF-XML\n element is as follows:\n\n\n   \noptimizer [ method=\n(gmsh|netgen):gmsh\n ] /\n\n\n\n\n\nThe \nmethod\n corresponds to either the \n-optimize\n or \n-optimize_netgen\n\noptimization flag of GMSH.", 
            "title": "Optimizer Component"
        }, 
        {
            "location": "/gssf/optimizer/#optimizer-gssf-component", 
            "text": "This is an extremely basic component, wrapping  GMSH  for mesh optimization.", 
            "title": "Optimizer GSSF Component"
        }, 
        {
            "location": "/gssf/optimizer/#configuration", 
            "text": "The second-level  GSSF-XML  element is as follows:      optimizer [ method= (gmsh|netgen):gmsh  ] /   The  method  corresponds to either the  -optimize  or  -optimize_netgen \noptimization flag of GMSH.", 
            "title": "Configuration"
        }, 
        {
            "location": "/gssf/elmergrid/", 
            "text": "ElmerGrid GSSF Component\n\n\nElmerGrid\n is a tool in\nthe Elmer suite for converting meshes from non-Elmer formats to formats suitable\nfor the Elmer solver. It is capable of performing some other manipulations also,\nand is generally used for scaling the meshes to metres prior to simulation.\n\n\nThe current implementation always adds a \n-removeunused\n flag. If the\nsimulation will use \nNP\n multiple processes, \n-metis NP\n is appended, and\n\n-scale X\n if some global scaling is required. Note that the scaling for the\nsimulation, from the original input mesh length-scale, normally takes place in\nthis component.\n\n\nConfiguration\n\n\nThe ElmerGrid component is configured through an \nelmergrid\n node in the\nGSSF-XML, as a first-level child.\n\n\nelmergrid [ scale=\"X Y Z\" ] [ skip=\"SKIP_ELMERGRID:false\" ]\n\n\n/elmergrid\n\n\n\n\nIf \nsimulationscaling\n constant is set globally and the \nscale\n attribute is\nnot provided, it will be used to set ElmerGrid scaling.\n\n\nNotes\n\n\n\n\nAs the total simulation scaling is based on the scaling from the \nNeedle\nLibrary\n and ElmerGrid components, they should appear in that\norder in the XML, for the moment. In general, order should be irrelevant (FIXME)", 
            "title": "ElmerGrid Component"
        }, 
        {
            "location": "/gssf/elmergrid/#elmergrid-gssf-component", 
            "text": "ElmerGrid  is a tool in\nthe Elmer suite for converting meshes from non-Elmer formats to formats suitable\nfor the Elmer solver. It is capable of performing some other manipulations also,\nand is generally used for scaling the meshes to metres prior to simulation.  The current implementation always adds a  -removeunused  flag. If the\nsimulation will use  NP  multiple processes,  -metis NP  is appended, and -scale X  if some global scaling is required. Note that the scaling for the\nsimulation, from the original input mesh length-scale, normally takes place in\nthis component.", 
            "title": "ElmerGrid GSSF Component"
        }, 
        {
            "location": "/gssf/elmergrid/#configuration", 
            "text": "The ElmerGrid component is configured through an  elmergrid  node in the\nGSSF-XML, as a first-level child.  elmergrid [ scale=\"X Y Z\" ] [ skip=\"SKIP_ELMERGRID:false\" ]  /elmergrid   If  simulationscaling  constant is set globally and the  scale  attribute is\nnot provided, it will be used to set ElmerGrid scaling.", 
            "title": "Configuration"
        }, 
        {
            "location": "/gssf/elmergrid/#notes", 
            "text": "As the total simulation scaling is based on the scaling from the  Needle\nLibrary  and ElmerGrid components, they should appear in that\norder in the XML, for the moment. In general, order should be irrelevant (FIXME)", 
            "title": "Notes"
        }, 
        {
            "location": "/gssf/elmer/", 
            "text": "ElmerSolver GSSF Component\n\n\nElmerSolver\n is the\nsimulation tool within the Elmer suite. This GSSF component prepares\nconfiguration for it based on the GSSF-XML input, runs it and monitors it for\npercentage progress.\n\n\nElmer SIF template\n\n\nThe Elmer SIF provides the configuration of the solver. It is generated from\na \nJinja2\n template, which is supplied in the GSSF-XML.\nParameter dictionaries provide access to the global GSSF parameter list\nfrom the template - see \nConstants (Parameters)\n for more detail.\n\n\nIn addition to the global parameter dictionary, \np\n, and the dictionary of\nneedle parameter dictionaries \nneedles\n, there is a counter dictionary, \nc\n. It may used\nin a similar fashion to the parameter dictionaries, by member syntax. If a\nmember \nc.BODY\n, say, has not been used before, its first usage will return \n1\n.\nThe second will return \n2\n and so forth. Prefixing the member with an\nunderscore, \nc._BODY\n will return the current index without incrementing.\n\n\nNote that, while the GSSA simulation server scrubs SIF files, GSSF itself does\nnot. As such, if running GSSF separately \nyou should only accept SIF templates from trusted sources\n,\nSpecifically, several MATC functions provide access to the filesystem or printf,\nso precautions should be taken.\n\n\nAlgorithms\n in MATC will be written to a file with a unique\nID. A line sourcing it will be added at the end of the SIF, and the constant\nrepresenting the result, will be substituted with a call to it. For instance,\n\nElectric conductivity = {{ p.ELECTRIC_CONDUCTIVITY }}\n, when with an algorithm\nwith result \nELECTRIC_CONDUCTIVITY\n based on Argument \nTemperature\n is provided,\nwould become:\n\n\nElectric conductivity = Variable Temperature\n    Real MATC \"ELECTRIC_CONDUCTIVITY(tx(0))\"\n\n\n\nThe following filters are available, in addition to basic Jinja2 sandbox\nfilters:\n\n\n\n\n\n\n\n\nFilter name\n\n\nApply to\n\n\nPurpose\n\n\nParameters\n\n\n\n\n\n\n\n\n\n\ntyped\n\n\nParameter\n\n\nrender parameter with SIF type prefix\n\n\n-\n\n\n\n\n\n\ntotyped\n\n\nany Parameter-wrappable value\n\n\nrender value with SIF type prefix based on type \nd\n\n\nd\n (desired type)\n\n\n\n\n\n\ndiscretize\n\n\nnumber\n\n\nround to nearest \nr\n (returns int if \nr\n \n= 1)\n\n\nr\n (granularity)\n\n\n\n\n\n\n\n\nThe following global functions are available, in addition to basic Jinja2\nsandbox globals:\n\n\n\n\n\n\n\n\nFunction\n\n\nArguments\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nzip\n\n\nas usu.\n\n\nPython built-in\n\n\n\n\n\n\nlist\n\n\nas usu.\n\n\nPython built-in\n\n\n\n\n\n\nmap\n\n\nas usu.\n\n\nPython built-in\n\n\n\n\n\n\nstr\n\n\nas usu.\n\n\nPython built-in\n\n\n\n\n\n\nneedle_distance\n\n\nneedle1id\n,\nneedle2id\n,\n(opt) \nd\n,\n(opt) \nref\n\n\nreturns the perpendicular distance between \nneedle1\n and \nneedle2\n, optionally starting from \nd\n metres (or simulation scale) along shaft from tip of needle \nref\n (\nneedle1id\n or \nneedle2id\n)\n\n\n\n\n\n\n\n\nTIP\n: Elmer tends to die without reporting an error if there is a problem with a MATC function,\nsometimes with a segfault or an unpredictable number output. If you notice you\nare getting simulations failing at the solver step, it is recommended that you\nrun \nElmerSolver_mpi\n manually in the \nelmer\n folder to see\nwhether this is the case. If so, removing and progressively adding in MATC\nfunctions should clarify which is causing the problem.\n\n\nStatus updates\n\n\nThe solver module starts a socket listening on \npercentage.sock\n in the simulation\ndirectory. An Elmer solver (\nNumaProgress\n) is available to connect to and update this based on\nthe solver \nPercentage Progress\n value. By adding this solver into your SIF file\nand setting \nPercentage Progress\n within it, you can receive percentage updates in the main\nPython process.\n\n\nTODO: Add in user-configurable status text, after checking for security\nissues that may rise.\n\n\nRuntime compilation\n\n\nModels can be tagged with certain library Fortran modules, which are then used\nin the SIF file as user-defined functions (UDFs). For security reasons, only\npredefined modules are available, such as \nmwa_RelPerm\n or \nmwa_ElecCond\n, which\nprovide temperature-dependent relative permittivity and electric conductivity\nfor microwave ablation. These modules can contain GSSF constants, which are\ninserted before compilation. They must be cast to numeric types only to\nprevent injection and it is recommended that any new modules are used only in\nstandalone mode with trusted template input.\n\n\nIn general, it is recommended to avoid this method\nas it is harder to abstract and errors in adding modules can compromise security,\nat least until GSSF is reorganised for use inside\nthe Docker workflow and sandboxing allows for user-supplied routines.\n\n\nPoint source location factories\n\n\nFor the point source models, where a series of heating points defines the input\npower distribution, a factory is used to simplify setting of models. The factory\ncan output locations at various probe extensions without these needing to be\npre-calculated on the client-side, or in the CDM. For this to work correctly, at\nleast in the current version, there must only be one needle present in a\nsimulation at a time. If needed, a workaround may be to add additional heating\npoints for a secondary needle to the first, provided all extension lengths and\ntimes match.\n\n\nSeveral probe location factories are contained in the GSSF codebase. These may\nbe extended by subclassing \nGoSmartElmerProbeLocationFactory\n and adding to\nthe dictionary, \ngssf.elmer_probelocation.probe_location_factories\n.\n\n\nA number of thermocouples may be defined, which can be used to label each of the\nheating points. These are passed to the actual solver and,\nnormally, used to switch points on and off according to some thermocouple-based\nalgorithm. The remaining points are split between \nends\n and \nmiddles\n,\nwhich are generally used to distribute power between two different levels by\nthe simulation module.\n\n\nThe default factories are outlined below.\n\n\nManual Probe Location Factory\n\n\nGoSmartElmerProbeLocationFactoryManual\n is selected by setting the point\nsources \nsystem\n to \nmanual\n. This requires all points to be configured for\nGSSF-XML and assumes a single extension.\n\n\nThe \npointsources\n XML block should be formatted as follows:\n\n\npointsources system=\"manual\"\n\n  [(\n    \nends|middles|thermocouples\n\n      \nlocation x=\"X1\" y=\"Y1\" z=\"Z1\" t=\"T1\" /\n\n      ...\n    \n/ends|middles|thermocouples\n\n  |\n    \nends|middles|thermocouples input=\"block\"\n\n        X1  Y1  Z1  T1 (tabbed)\n      ...\n    \n/ends|middles|thermocouples\n\n  )]*\n\n/pointsources\n\n\n\n\nwhere \nT\n, an integer, is the index of the controlling thermocouple in the\nlist of point sources.\n\n\nStraight Tines Location Factory\n\n\nGoSmartElmerProbeLocationFactoryStraightTines\n generates all point locations\nbased only on the shaft location and (scalar) extensions. It assumes the locus\nfrom shaft tip to the end of each of the tines is linear. Note that this does\nnot, strictly, equate to the tine itself being linear, but states that there\nshould be a \nmiddle\n heating point at the mid-point of a line from the shaft tip to each\n\nend\n point.\n\n\nThe \npointsources\n XML block should be formatted as follows:\n\n\npointsources system=\"straight tines\" [ offset=\"X Y Z\" ]\n\n  \nextensions\n\n    \nextension phase=\"0\" length=\"L1\"/\n\n    \nextension phase=\"1\" length=\"L2\"/\n\n    ...\n  \n/extensions\n\n\n/pointsources\n\n\n\n\nThe \noffset\n parameter allows the user to change the point location relative to\nthe needle-shaft tip. The shaft location is taken from the geometry section.\n\nLn\n lengths should be provided in metres.\nNote that the change of phase over time is usually controlled via a simulation module.\n\n\nUmbrella Tines Location Factory\n\n\nGoSmartElmerProbeLocationFactoryUmbrellaTines\n provides an arched configuration\nof heating points, where the \nend\n is perpendicular to the tip and the \nmiddle\n\nis at an angle beyond the tip, such that opposing tines form an M shape.\n\n\nConfiguration is identical to the \nStraight Tines Location\nFactory\n, using \nsystem=\"umbrella tines\"\n.\n\n\nExtrapolated Tine Factory\n\n\nGoSmartElmerProbeLocationFactoryExtrapolated\n takes the tip locations for the\nlargest extension and scales accordingly for other extensions. Note that\nclinicians generally do imaging showing full extension before starting the\nprotocol (at least, in radiofrequency ablation), so this location information is\navailable at the beginning of the procedure.\n\n\nThe \npointsources\n XML block should be formatted as follows:\n\n\npointsources system=\"extrapolated\" [ offset=\"X Y Z\" ]\n\n  \nextensions\n\n    \nextension phase=\"0\" length=\"L1\"/\n\n    \nextension phase=\"1\" length=\"L2\"/\n\n    ...\n  \n/extensions\n\n  \npoints\n\n    \npoint i=\"1\" x=\"X1\" y=\"Y1\" z=\"Z1\"/\n\n    \npoint i=\"2\" x=\"X2\" y=\"Y2\" z=\"Z2\"/\n\n    ...\n  \n/points\n\n\n/pointsources\n\n\n\n\nConfiguration\n\n\nThe XML format for the \nelmer\n first-level configuration node is as follows:\n\n\nelmer [ skip=\"SKIP_ELMER:false\" ]\n\n    [ \nrestart time=\"RESTART_TIME\" position=\"RESTART_INDEX\" old=\"PREVIOUS_SIF_PREFIX\" /\n ]\n    [ \npointsources system=\"TINE_FACTORY\"\n\n        \n!-- AS DEFINED ABOVE --\n\n      \n/pointsources\n ]\n    (\n      \nvariant [ modules=\"f90module1; f90module2;...\" ] name=\"SIF_TEMPLATE_LIBRARY_NAME\" /\n\n    |\n      \nvariant [ modules=\"f90module1; f90module2;...\" ] \n\n        ! SIF TEMPLATE\n        !\n        ...\n      \n/variant\n\n    )\n    [ \nsettings\n\n        \nsetting|constant name=\"non-slug setting name\" value=\"CONSTANT_VALUE\" type=\"CONSTANT_TYPE\" /\n\n        ...\n      \n/settings\n ]\n    [ \nalgorithms\n\n        \nalgorithm\n\n            \narguments\n\n              \nargument name=\"ARGUMENT_NAME\" /\n\n            \n/arguments\n\n            \ncontent\n\n              \n!-- Algorithm content - usu. MATC --\n\n            \n/content\n\n        \n/algorithm\n\n        ...\n      \n/algorithms\n ]\n\n/elmer\n\n\n\n\nNote that \nnon-slug setting name\n will translate to\n\nSETTING_NON_SLUG_SETTING_NAME\n in the SIF parameter dictionary.", 
            "title": "ElmerSolver Component"
        }, 
        {
            "location": "/gssf/elmer/#elmersolver-gssf-component", 
            "text": "ElmerSolver  is the\nsimulation tool within the Elmer suite. This GSSF component prepares\nconfiguration for it based on the GSSF-XML input, runs it and monitors it for\npercentage progress.", 
            "title": "ElmerSolver GSSF Component"
        }, 
        {
            "location": "/gssf/elmer/#elmer-sif-template", 
            "text": "The Elmer SIF provides the configuration of the solver. It is generated from\na  Jinja2  template, which is supplied in the GSSF-XML.\nParameter dictionaries provide access to the global GSSF parameter list\nfrom the template - see  Constants (Parameters)  for more detail.  In addition to the global parameter dictionary,  p , and the dictionary of\nneedle parameter dictionaries  needles , there is a counter dictionary,  c . It may used\nin a similar fashion to the parameter dictionaries, by member syntax. If a\nmember  c.BODY , say, has not been used before, its first usage will return  1 .\nThe second will return  2  and so forth. Prefixing the member with an\nunderscore,  c._BODY  will return the current index without incrementing.  Note that, while the GSSA simulation server scrubs SIF files, GSSF itself does\nnot. As such, if running GSSF separately  you should only accept SIF templates from trusted sources ,\nSpecifically, several MATC functions provide access to the filesystem or printf,\nso precautions should be taken.  Algorithms  in MATC will be written to a file with a unique\nID. A line sourcing it will be added at the end of the SIF, and the constant\nrepresenting the result, will be substituted with a call to it. For instance, Electric conductivity = {{ p.ELECTRIC_CONDUCTIVITY }} , when with an algorithm\nwith result  ELECTRIC_CONDUCTIVITY  based on Argument  Temperature  is provided,\nwould become:  Electric conductivity = Variable Temperature\n    Real MATC \"ELECTRIC_CONDUCTIVITY(tx(0))\"  The following filters are available, in addition to basic Jinja2 sandbox\nfilters:     Filter name  Apply to  Purpose  Parameters      typed  Parameter  render parameter with SIF type prefix  -    totyped  any Parameter-wrappable value  render value with SIF type prefix based on type  d  d  (desired type)    discretize  number  round to nearest  r  (returns int if  r   = 1)  r  (granularity)     The following global functions are available, in addition to basic Jinja2\nsandbox globals:     Function  Arguments  Description      zip  as usu.  Python built-in    list  as usu.  Python built-in    map  as usu.  Python built-in    str  as usu.  Python built-in    needle_distance  needle1id , needle2id , (opt)  d , (opt)  ref  returns the perpendicular distance between  needle1  and  needle2 , optionally starting from  d  metres (or simulation scale) along shaft from tip of needle  ref  ( needle1id  or  needle2id )     TIP : Elmer tends to die without reporting an error if there is a problem with a MATC function,\nsometimes with a segfault or an unpredictable number output. If you notice you\nare getting simulations failing at the solver step, it is recommended that you\nrun  ElmerSolver_mpi  manually in the  elmer  folder to see\nwhether this is the case. If so, removing and progressively adding in MATC\nfunctions should clarify which is causing the problem.", 
            "title": "Elmer SIF template"
        }, 
        {
            "location": "/gssf/elmer/#status-updates", 
            "text": "The solver module starts a socket listening on  percentage.sock  in the simulation\ndirectory. An Elmer solver ( NumaProgress ) is available to connect to and update this based on\nthe solver  Percentage Progress  value. By adding this solver into your SIF file\nand setting  Percentage Progress  within it, you can receive percentage updates in the main\nPython process.  TODO: Add in user-configurable status text, after checking for security\nissues that may rise.", 
            "title": "Status updates"
        }, 
        {
            "location": "/gssf/elmer/#runtime-compilation", 
            "text": "Models can be tagged with certain library Fortran modules, which are then used\nin the SIF file as user-defined functions (UDFs). For security reasons, only\npredefined modules are available, such as  mwa_RelPerm  or  mwa_ElecCond , which\nprovide temperature-dependent relative permittivity and electric conductivity\nfor microwave ablation. These modules can contain GSSF constants, which are\ninserted before compilation. They must be cast to numeric types only to\nprevent injection and it is recommended that any new modules are used only in\nstandalone mode with trusted template input.  In general, it is recommended to avoid this method\nas it is harder to abstract and errors in adding modules can compromise security,\nat least until GSSF is reorganised for use inside\nthe Docker workflow and sandboxing allows for user-supplied routines.", 
            "title": "Runtime compilation"
        }, 
        {
            "location": "/gssf/elmer/#point-source-location-factories", 
            "text": "For the point source models, where a series of heating points defines the input\npower distribution, a factory is used to simplify setting of models. The factory\ncan output locations at various probe extensions without these needing to be\npre-calculated on the client-side, or in the CDM. For this to work correctly, at\nleast in the current version, there must only be one needle present in a\nsimulation at a time. If needed, a workaround may be to add additional heating\npoints for a secondary needle to the first, provided all extension lengths and\ntimes match.  Several probe location factories are contained in the GSSF codebase. These may\nbe extended by subclassing  GoSmartElmerProbeLocationFactory  and adding to\nthe dictionary,  gssf.elmer_probelocation.probe_location_factories .  A number of thermocouples may be defined, which can be used to label each of the\nheating points. These are passed to the actual solver and,\nnormally, used to switch points on and off according to some thermocouple-based\nalgorithm. The remaining points are split between  ends  and  middles ,\nwhich are generally used to distribute power between two different levels by\nthe simulation module.  The default factories are outlined below.  Manual Probe Location Factory  GoSmartElmerProbeLocationFactoryManual  is selected by setting the point\nsources  system  to  manual . This requires all points to be configured for\nGSSF-XML and assumes a single extension.  The  pointsources  XML block should be formatted as follows:  pointsources system=\"manual\" \n  [(\n     ends|middles|thermocouples \n       location x=\"X1\" y=\"Y1\" z=\"Z1\" t=\"T1\" / \n      ...\n     /ends|middles|thermocouples \n  |\n     ends|middles|thermocouples input=\"block\" \n        X1  Y1  Z1  T1 (tabbed)\n      ...\n     /ends|middles|thermocouples \n  )]* /pointsources   where  T , an integer, is the index of the controlling thermocouple in the\nlist of point sources.  Straight Tines Location Factory  GoSmartElmerProbeLocationFactoryStraightTines  generates all point locations\nbased only on the shaft location and (scalar) extensions. It assumes the locus\nfrom shaft tip to the end of each of the tines is linear. Note that this does\nnot, strictly, equate to the tine itself being linear, but states that there\nshould be a  middle  heating point at the mid-point of a line from the shaft tip to each end  point.  The  pointsources  XML block should be formatted as follows:  pointsources system=\"straight tines\" [ offset=\"X Y Z\" ] \n   extensions \n     extension phase=\"0\" length=\"L1\"/ \n     extension phase=\"1\" length=\"L2\"/ \n    ...\n   /extensions  /pointsources   The  offset  parameter allows the user to change the point location relative to\nthe needle-shaft tip. The shaft location is taken from the geometry section. Ln  lengths should be provided in metres.\nNote that the change of phase over time is usually controlled via a simulation module.  Umbrella Tines Location Factory  GoSmartElmerProbeLocationFactoryUmbrellaTines  provides an arched configuration\nof heating points, where the  end  is perpendicular to the tip and the  middle \nis at an angle beyond the tip, such that opposing tines form an M shape.  Configuration is identical to the  Straight Tines Location\nFactory , using  system=\"umbrella tines\" .  Extrapolated Tine Factory  GoSmartElmerProbeLocationFactoryExtrapolated  takes the tip locations for the\nlargest extension and scales accordingly for other extensions. Note that\nclinicians generally do imaging showing full extension before starting the\nprotocol (at least, in radiofrequency ablation), so this location information is\navailable at the beginning of the procedure.  The  pointsources  XML block should be formatted as follows:  pointsources system=\"extrapolated\" [ offset=\"X Y Z\" ] \n   extensions \n     extension phase=\"0\" length=\"L1\"/ \n     extension phase=\"1\" length=\"L2\"/ \n    ...\n   /extensions \n   points \n     point i=\"1\" x=\"X1\" y=\"Y1\" z=\"Z1\"/ \n     point i=\"2\" x=\"X2\" y=\"Y2\" z=\"Z2\"/ \n    ...\n   /points  /pointsources", 
            "title": "Point source location factories"
        }, 
        {
            "location": "/gssf/elmer/#configuration", 
            "text": "The XML format for the  elmer  first-level configuration node is as follows:  elmer [ skip=\"SKIP_ELMER:false\" ] \n    [  restart time=\"RESTART_TIME\" position=\"RESTART_INDEX\" old=\"PREVIOUS_SIF_PREFIX\" /  ]\n    [  pointsources system=\"TINE_FACTORY\" \n         !-- AS DEFINED ABOVE -- \n       /pointsources  ]\n    (\n       variant [ modules=\"f90module1; f90module2;...\" ] name=\"SIF_TEMPLATE_LIBRARY_NAME\" / \n    |\n       variant [ modules=\"f90module1; f90module2;...\" ]  \n        ! SIF TEMPLATE\n        !\n        ...\n       /variant \n    )\n    [  settings \n         setting|constant name=\"non-slug setting name\" value=\"CONSTANT_VALUE\" type=\"CONSTANT_TYPE\" / \n        ...\n       /settings  ]\n    [  algorithms \n         algorithm \n             arguments \n               argument name=\"ARGUMENT_NAME\" / \n             /arguments \n             content \n               !-- Algorithm content - usu. MATC -- \n             /content \n         /algorithm \n        ...\n       /algorithms  ] /elmer   Note that  non-slug setting name  will translate to SETTING_NON_SLUG_SETTING_NAME  in the SIF parameter dictionary.", 
            "title": "Configuration"
        }, 
        {
            "location": "/gssf/lesion/", 
            "text": "Lesion-Extracting GSSF Component\n\n\nThis component wraps a separate tool, \ngo-smart-lesion\n, which uses\n\nVTK\n routines to extract a lesion surface. More generally,\nthis component extracts an isosurface based on certain criteria.\n\n\nConfiguration\n\n\nWhen running \ngo-smart-lesion\n as part of the GSSF workflow, the Python component can be configured as follows:\n\n\n    \nlesion field=\nFIELD\n\n            [ threshold_lower=\nTHRESHOLDLOWER\n ] [ threshold_upper=\nTHRESHOLDUPPER\n ] \n            [ selection=\n(most-recent|largest-time):most-recent\n ]\n            [ connectivity=\nBOOL:false\n ]\n            [ scaling=\nFLOAT\n ] /\n\n\n\n\n\nIf \nscaling\n is omitted, the inverse of\n\nsimulationscaling\n is used. This returns the simulation\nto the original, input length scale. If \nconnectivity\n is \ntrue\n, the largest\ncomponent only will be extracted. To choose a specific simulation timeslice for\ninput, the \nselection\n attribute can be set to either \nmost-recent\n, for the\nmost recently modified file in the \nElmer\n output directory, or\n\nlargest-time\n to choose the timeslice with the highest timestep suffix. On a\nclean run, these should pick the same output VTU file. The \nTHRESHOLDUPPER\n and\n\nTHRESHOLDLOWER\n values, if provided, will be used in a VTK \nThresholdBetween\n\ncall. If only one is provided, \nThresholdUpper\n or \nThresholdLower\n will be\nused. Note that this is the reverse of the VTK definition - we treat\n\nTHRESHOLDUPPER\n as the maximum accepted value within the lesion, and\n\nTHRESHOLDLOWER\n as the minimum. \nFIELD\n should be a field present in the VTU\nfile, which should correspond to variables output from the SIF template. Note\nthat Elmer seems to lowercase variable names before output, so \nFIELD\n should\nalso be lowercase even if the SIF template uses mixed/uppercase.\n\n\ngo-smart-lesion\n\n\ngo-smart-lesion\n may be run standalone from the shell. If so, the syntax is as follows:\n\n\ngo-smart-lesion OPTIONS\n\n\n\nOptional arguments\n\n\n\n\n\n\n\n\nArgument\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n-h [ --help ]\n\n\nproduce help message\n\n\n\n\n\n\n-t [ --threshold-lower ] arg\n\n\nthreshold for chosen variable (remove cells with values below this limit)\n\n\n\n\n\n\n-T [ --threshold-upper ] arg\n\n\nthreshold for chosen variable (remove cells with values above this limit)\n\n\n\n\n\n\n-S [ --scale ] arg (=1)\n\n\npre-scaling of results; default 1\n\n\n\n\n\n\n-f [ --field ] arg\n\n\nfield to threshold on\n\n\n\n\n\n\n-p [ --parallel ]\n\n\nassume input data is PVTU not VTU\n\n\n\n\n\n\n-x [ --threshold ]\n\n\nswitch from using an IsoVolume to using a Threshold\n\n\n\n\n\n\n-c [ --connectivity ]\n\n\nextract largest connected component of thresholded surface\n\n\n\n\n\n\n-s [ --subdivide ]\n\n\nsubdivide before thresholding\n\n\n\n\n\n\n-i [ --smoothing-iterations ] arg (=0)\n\n\nnumber of iterations in smoother (0 to skip)\n\n\n\n\n\n\n-e [ --exclude-subdomain ] arg (=-1)\n\n\nexclude subdomain of given index\n\n\n\n\n\n\n-i [ --input ] arg\n\n\ninput volume mesh file\n\n\n\n\n\n\n-a [ --analysis ] arg\n\n\nanalysis output file\n\n\n\n\n\n\n-o [ --output ] arg\n\n\noutput file\n\n\n\n\n\n\n-r [ --retain-subdomain-boundaries ]\n\n\nretain all internal inter-zone boundary facets\n\n\n\n\n\n\n-g [ --geometry-filter ]\n\n\nuse geometry filter instead of vtkDataSetSurfaceFilter to extract surface", 
            "title": "Lesion Component"
        }, 
        {
            "location": "/gssf/lesion/#lesion-extracting-gssf-component", 
            "text": "This component wraps a separate tool,  go-smart-lesion , which uses VTK  routines to extract a lesion surface. More generally,\nthis component extracts an isosurface based on certain criteria.", 
            "title": "Lesion-Extracting GSSF Component"
        }, 
        {
            "location": "/gssf/lesion/#configuration", 
            "text": "When running  go-smart-lesion  as part of the GSSF workflow, the Python component can be configured as follows:       lesion field= FIELD \n            [ threshold_lower= THRESHOLDLOWER  ] [ threshold_upper= THRESHOLDUPPER  ] \n            [ selection= (most-recent|largest-time):most-recent  ]\n            [ connectivity= BOOL:false  ]\n            [ scaling= FLOAT  ] /   If  scaling  is omitted, the inverse of simulationscaling  is used. This returns the simulation\nto the original, input length scale. If  connectivity  is  true , the largest\ncomponent only will be extracted. To choose a specific simulation timeslice for\ninput, the  selection  attribute can be set to either  most-recent , for the\nmost recently modified file in the  Elmer  output directory, or largest-time  to choose the timeslice with the highest timestep suffix. On a\nclean run, these should pick the same output VTU file. The  THRESHOLDUPPER  and THRESHOLDLOWER  values, if provided, will be used in a VTK  ThresholdBetween \ncall. If only one is provided,  ThresholdUpper  or  ThresholdLower  will be\nused. Note that this is the reverse of the VTK definition - we treat THRESHOLDUPPER  as the maximum accepted value within the lesion, and THRESHOLDLOWER  as the minimum.  FIELD  should be a field present in the VTU\nfile, which should correspond to variables output from the SIF template. Note\nthat Elmer seems to lowercase variable names before output, so  FIELD  should\nalso be lowercase even if the SIF template uses mixed/uppercase.", 
            "title": "Configuration"
        }, 
        {
            "location": "/gssf/lesion/#go-smart-lesion", 
            "text": "go-smart-lesion  may be run standalone from the shell. If so, the syntax is as follows:  go-smart-lesion OPTIONS  Optional arguments     Argument  Description      -h [ --help ]  produce help message    -t [ --threshold-lower ] arg  threshold for chosen variable (remove cells with values below this limit)    -T [ --threshold-upper ] arg  threshold for chosen variable (remove cells with values above this limit)    -S [ --scale ] arg (=1)  pre-scaling of results; default 1    -f [ --field ] arg  field to threshold on    -p [ --parallel ]  assume input data is PVTU not VTU    -x [ --threshold ]  switch from using an IsoVolume to using a Threshold    -c [ --connectivity ]  extract largest connected component of thresholded surface    -s [ --subdivide ]  subdivide before thresholding    -i [ --smoothing-iterations ] arg (=0)  number of iterations in smoother (0 to skip)    -e [ --exclude-subdomain ] arg (=-1)  exclude subdomain of given index    -i [ --input ] arg  input volume mesh file    -a [ --analysis ] arg  analysis output file    -o [ --output ] arg  output file    -r [ --retain-subdomain-boundaries ]  retain all internal inter-zone boundary facets    -g [ --geometry-filter ]  use geometry filter instead of vtkDataSetSurfaceFilter to extract surface", 
            "title": "go-smart-lesion"
        }, 
        {
            "location": "/gssf/validation/", 
            "text": "Go-Smart Simulation Framework - Validation Component\n\n\nThis component manages the validation step, comparing the output STL ablation\nlesion surface and a separately provided segmented validation STL surface.\n\n\nNote\n: this component is configured to wrap the (closed source) Aalto\nValidation Tool. For further details, please contact \nAalto\nUniversity\n.\n\n\nConfiguration\n\n\nThis tool is configured as follows:\n\n\n    \nvalidation reference=\nREFERENCEREGION\n [ registration=\nBOOL:true\n ] /\n\n\n\n\n\nThe \nREFERENCEREGION\n should be defined  in the \nregions\n section of\n\nGSSF-XML\n and provides the surface to which the lesion output by the\n\nlesion\n component will be compared. If \nregistration\n is \ntrue\n, the\ncomparison will be made after an error minimizing rigid transformation,\neffectively providing post-operative registration. If \nfalse\n, it assumes\nregistration of post- to pre-operative images has already occurred.", 
            "title": "Validation Component"
        }, 
        {
            "location": "/gssf/validation/#go-smart-simulation-framework-validation-component", 
            "text": "This component manages the validation step, comparing the output STL ablation\nlesion surface and a separately provided segmented validation STL surface.  Note : this component is configured to wrap the (closed source) Aalto\nValidation Tool. For further details, please contact  Aalto\nUniversity .", 
            "title": "Go-Smart Simulation Framework - Validation Component"
        }, 
        {
            "location": "/gssf/validation/#configuration", 
            "text": "This tool is configured as follows:       validation reference= REFERENCEREGION  [ registration= BOOL:true  ] /   The  REFERENCEREGION  should be defined  in the  regions  section of GSSF-XML  and provides the surface to which the lesion output by the lesion  component will be compared. If  registration  is  true , the\ncomparison will be made after an error minimizing rigid transformation,\neffectively providing post-operative registration. If  false , it assumes\nregistration of post- to pre-operative images has already occurred.", 
            "title": "Configuration"
        }, 
        {
            "location": "/gssf/numa-elmer/", 
            "text": "Extensions to the Elmer Project included in GSSF\n\n\nAs part of GSSF,\nwe have incorporated some minor alterations to the upstream solver, and\nadded a series of plug-in solver modules, to simplify GSSA integration or better\nsupport the ablation context.\n\n\nUpstream submission\n\n\nThe modifications to the upstream version of Elmer are branched from the\n\nGithub\n source tree to simplify\ncontribution.", 
            "title": "Extensions to Elmer"
        }, 
        {
            "location": "/gssf/numa-elmer/#extensions-to-the-elmer-project-included-in-gssf", 
            "text": "As part of GSSF,\nwe have incorporated some minor alterations to the upstream solver, and\nadded a series of plug-in solver modules, to simplify GSSA integration or better\nsupport the ablation context.", 
            "title": "Extensions to the Elmer Project included in GSSF"
        }, 
        {
            "location": "/gssf/numa-elmer/#upstream-submission", 
            "text": "The modifications to the upstream version of Elmer are branched from the Github  source tree to simplify\ncontribution.", 
            "title": "Upstream submission"
        }, 
        {
            "location": "/gssf/utilities/", 
            "text": "Utility Functions in GSSF\n\n\nThere are several helper functions used in GSSF that may be of use if you are\nextending or modifying behaviour. While these are underscore prefixed, this may\nbe changed later - however, they are intended for use within the gssf.*\nspace.\n\n\ngenerate_rotation_matrix\n\n\nLocation\n: \ngssf.globals._generate_rotation_matrix(x, y, z, backward=False)\n,\n\n_generate_numpy_rotation_matrix(x, y, z, backward=False, rx=0, ry=1, rz=0)\n\n\nThe \nNumpy\n version of this function creates a rotation\n\nmatrix\n\ntaking the vector \n(rx, ry, rz)\n to \n(x, y, z)\n, rotating about an axis\nperpendicular to both. The \nbackward\n argument allows for easy reversal of the\nrotation. The algorithm used is \nRodrigues' rotation\nformula\n.\nThe non-Numpy version renders the matrix as a SIF-embeddedable space-separated\nlist.\n\n\nThis utility is especially useful for translating needles from reference\ncoordinates to the embedded location and for moving backwards and forwards between\nan axisymmetric problem and its 3D embedding. Note that reference needles in the\nGSSF library are aligned to \n(0, 0, 1)\n, not \n(0, 1, 0)\n. However, library\naxisymmetric meshes lie in this plane. \nExtensions\n to the mesh\ninterpolation functionality in Elmer allow\n\n\nslugify\n\n\nLocation\n: \ngssf.globals.slugify(inp)\n\n\nThis is a workaround for lack of a Python3 slugify early in the project, and is\nto be replaced with a real slugify (e.g.\n\npython-slugify\n). It is documented\nhere solely because any differences between our (very basic, 4-line) behaviour\nand an upstream slugify's needs to be considered before swapping.\n\n\nIt uppercases input, removes any parentheses and replaces dash and space with an\nunderscore. For example:\n\n\n\"Electric conductivity (tissue)\" ----\n ELECTRIC_CONDUCTIVITY_TISSUE\n\n\n\nThis is normally seen in generation of constant names for the parameter\ndictionaries in the SIF template.", 
            "title": "Utilities"
        }, 
        {
            "location": "/gssf/utilities/#utility-functions-in-gssf", 
            "text": "There are several helper functions used in GSSF that may be of use if you are\nextending or modifying behaviour. While these are underscore prefixed, this may\nbe changed later - however, they are intended for use within the gssf.*\nspace.", 
            "title": "Utility Functions in GSSF"
        }, 
        {
            "location": "/gssf/utilities/#generate_rotation_matrix", 
            "text": "Location :  gssf.globals._generate_rotation_matrix(x, y, z, backward=False) , _generate_numpy_rotation_matrix(x, y, z, backward=False, rx=0, ry=1, rz=0)  The  Numpy  version of this function creates a rotation matrix \ntaking the vector  (rx, ry, rz)  to  (x, y, z) , rotating about an axis\nperpendicular to both. The  backward  argument allows for easy reversal of the\nrotation. The algorithm used is  Rodrigues' rotation\nformula .\nThe non-Numpy version renders the matrix as a SIF-embeddedable space-separated\nlist.  This utility is especially useful for translating needles from reference\ncoordinates to the embedded location and for moving backwards and forwards between\nan axisymmetric problem and its 3D embedding. Note that reference needles in the\nGSSF library are aligned to  (0, 0, 1) , not  (0, 1, 0) . However, library\naxisymmetric meshes lie in this plane.  Extensions  to the mesh\ninterpolation functionality in Elmer allow", 
            "title": "generate_rotation_matrix"
        }, 
        {
            "location": "/gssf/utilities/#slugify", 
            "text": "Location :  gssf.globals.slugify(inp)  This is a workaround for lack of a Python3 slugify early in the project, and is\nto be replaced with a real slugify (e.g. python-slugify ). It is documented\nhere solely because any differences between our (very basic, 4-line) behaviour\nand an upstream slugify's needs to be considered before swapping.  It uppercases input, removes any parentheses and replaces dash and space with an\nunderscore. For example:  \"Electric conductivity (tissue)\" ----  ELECTRIC_CONDUCTIVITY_TISSUE  This is normally seen in generation of constant names for the parameter\ndictionaries in the SIF template.", 
            "title": "slugify"
        }
    ]
}